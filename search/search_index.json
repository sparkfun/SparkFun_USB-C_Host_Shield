{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"<p>This is just a placeholder file for the webpage re-direct. All the content for this section is actually in the <code>introduction.md</code> file.</p>"},{"location":"example-usb_desc/","title":"Device Description","text":""},{"location":"example-usb_desc/#usb-description","title":"USB Description","text":"<p>For our first example, we will be utilizing the USB_dec example from the USB_Host_Shield_2.0 Arduino library. This example can be found in the File dropdown menu (i.e. (1) File &gt; Examples &gt; USB Host Shield Library 2.0 &gt; USB_Desc). Once the example has been opened, users should see two files <code>USB_desc.ino</code> and <code>pgmstrings.h</code>.</p> <ol> <li> Select the <code>USB_Desc</code> example sketch from the <code>File</code> drop-down menu. </li> </ol> Example Files USB_desc.inopgmstrings.h <pre><code>#include &lt;usbhub.h&gt;\n\n#include \"pgmstrings.h\"\n\n// Satisfy the IDE, which needs to see the include statment in the ino too.\n#ifdef dobogusinclude\n#include &lt;spi4teensy3.h&gt;\n#endif\n#include &lt;SPI.h&gt;\n\nUSB     Usb;\n//USBHub  Hub1(&amp;Usb);\n//USBHub  Hub2(&amp;Usb);\n//USBHub  Hub3(&amp;Usb);\n//USBHub  Hub4(&amp;Usb);\n//USBHub  Hub5(&amp;Usb);\n//USBHub  Hub6(&amp;Usb);\n//USBHub  Hub7(&amp;Usb);\n\nvoid PrintAllAddresses(UsbDevice *pdev)\n{\n  UsbDeviceAddress adr;\n  adr.devAddress = pdev-&gt;address.devAddress;\n  Serial.print(\"\\r\\nAddr:\");\n  Serial.print(adr.devAddress, HEX);\n  Serial.print(\"(\");\n  Serial.print(adr.bmHub, HEX);\n  Serial.print(\".\");\n  Serial.print(adr.bmParent, HEX);\n  Serial.print(\".\");\n  Serial.print(adr.bmAddress, HEX);\n  Serial.println(\")\");\n}\n\nvoid PrintAddress(uint8_t addr)\n{\n  UsbDeviceAddress adr;\n  adr.devAddress = addr;\n  Serial.print(\"\\r\\nADDR:\\t\");\n  Serial.println(adr.devAddress, HEX);\n  Serial.print(\"DEV:\\t\");\n  Serial.println(adr.bmAddress, HEX);\n  Serial.print(\"PRNT:\\t\");\n  Serial.println(adr.bmParent, HEX);\n  Serial.print(\"HUB:\\t\");\n  Serial.println(adr.bmHub, HEX);\n}\n\nvoid setup()\n{\n  Serial.begin( 115200 );\n#if !defined(__MIPSEL__)\n  while (!Serial); // Wait for serial port to connect - used on Leonardo, Teensy and other boards with built-in USB CDC serial connection\n#endif\n  Serial.println(\"Start\");\n\n  if (Usb.Init() == -1)\n    Serial.println(\"OSC did not start.\");\n\n  delay( 200 );\n}\n\nuint8_t getdevdescr( uint8_t addr, uint8_t &amp;num_conf );\n\nvoid PrintDescriptors(uint8_t addr)\n{\n  uint8_t rcode = 0;\n  uint8_t num_conf = 0;\n\n  rcode = getdevdescr( (uint8_t)addr, num_conf );\n  if ( rcode )\n  {\n    printProgStr(Gen_Error_str);\n    print_hex( rcode, 8 );\n  }\n  Serial.print(\"\\r\\n\");\n\n  for (int i = 0; i &lt; num_conf; i++)\n  {\n    rcode = getconfdescr( addr, i );                 // get configuration descriptor\n    if ( rcode )\n    {\n      printProgStr(Gen_Error_str);\n      print_hex(rcode, 8);\n    }\n    Serial.println(\"\\r\\n\");\n  }\n}\n\nvoid PrintAllDescriptors(UsbDevice *pdev)\n{\n  Serial.println(\"\\r\\n\");\n  print_hex(pdev-&gt;address.devAddress, 8);\n  Serial.println(\"\\r\\n--\");\n  PrintDescriptors( pdev-&gt;address.devAddress );\n}\n\nvoid loop()\n{\n  Usb.Task();\n\n  if ( Usb.getUsbTaskState() == USB_STATE_RUNNING )\n  {\n    Usb.ForEachUsbDevice(&amp;PrintAllDescriptors);\n    Usb.ForEachUsbDevice(&amp;PrintAllAddresses);\n\n    while ( 1 ) { // stop\n#ifdef ESP8266\n        yield(); // needed in order to reset the watchdog timer on the ESP8266\n#endif\n    }\n  }\n}\n\nuint8_t getdevdescr( uint8_t addr, uint8_t &amp;num_conf )\n{\n  USB_DEVICE_DESCRIPTOR buf;\n  uint8_t rcode;\n  rcode = Usb.getDevDescr( addr, 0, 0x12, ( uint8_t *)&amp;buf );\n  if ( rcode ) {\n    return ( rcode );\n  }\n  printProgStr(Dev_Header_str);\n  printProgStr(Dev_Length_str);\n  print_hex( buf.bLength, 8 );\n  printProgStr(Dev_Type_str);\n  print_hex( buf.bDescriptorType, 8 );\n  printProgStr(Dev_Version_str);\n  print_hex( buf.bcdUSB, 16 );\n  printProgStr(Dev_Class_str);\n  print_hex( buf.bDeviceClass, 8 );\n  printProgStr(Dev_Subclass_str);\n  print_hex( buf.bDeviceSubClass, 8 );\n  printProgStr(Dev_Protocol_str);\n  print_hex( buf.bDeviceProtocol, 8 );\n  printProgStr(Dev_Pktsize_str);\n  print_hex( buf.bMaxPacketSize0, 8 );\n  printProgStr(Dev_Vendor_str);\n  print_hex( buf.idVendor, 16 );\n  printProgStr(Dev_Product_str);\n  print_hex( buf.idProduct, 16 );\n  printProgStr(Dev_Revision_str);\n  print_hex( buf.bcdDevice, 16 );\n  printProgStr(Dev_Mfg_str);\n  print_hex( buf.iManufacturer, 8 );\n  printProgStr(Dev_Prod_str);\n  print_hex( buf.iProduct, 8 );\n  printProgStr(Dev_Serial_str);\n  print_hex( buf.iSerialNumber, 8 );\n  printProgStr(Dev_Nconf_str);\n  print_hex( buf.bNumConfigurations, 8 );\n  num_conf = buf.bNumConfigurations;\n  return ( 0 );\n}\n\nvoid printhubdescr(uint8_t *descrptr, uint8_t addr)\n{\n  HubDescriptor  *pHub = (HubDescriptor*) descrptr;\n  uint8_t        len = *((uint8_t*)descrptr);\n\n  printProgStr(PSTR(\"\\r\\n\\r\\nHub Descriptor:\\r\\n\"));\n  printProgStr(PSTR(\"bDescLength:\\t\\t\"));\n  Serial.println(pHub-&gt;bDescLength, HEX);\n\n  printProgStr(PSTR(\"bDescriptorType:\\t\"));\n  Serial.println(pHub-&gt;bDescriptorType, HEX);\n\n  printProgStr(PSTR(\"bNbrPorts:\\t\\t\"));\n  Serial.println(pHub-&gt;bNbrPorts, HEX);\n\n  printProgStr(PSTR(\"LogPwrSwitchMode:\\t\"));\n  Serial.println(pHub-&gt;LogPwrSwitchMode, BIN);\n\n  printProgStr(PSTR(\"CompoundDevice:\\t\\t\"));\n  Serial.println(pHub-&gt;CompoundDevice, BIN);\n\n  printProgStr(PSTR(\"OverCurrentProtectMode:\\t\"));\n  Serial.println(pHub-&gt;OverCurrentProtectMode, BIN);\n\n  printProgStr(PSTR(\"TTThinkTime:\\t\\t\"));\n  Serial.println(pHub-&gt;TTThinkTime, BIN);\n\n  printProgStr(PSTR(\"PortIndicatorsSupported:\"));\n  Serial.println(pHub-&gt;PortIndicatorsSupported, BIN);\n\n  printProgStr(PSTR(\"Reserved:\\t\\t\"));\n  Serial.println(pHub-&gt;Reserved, HEX);\n\n  printProgStr(PSTR(\"bPwrOn2PwrGood:\\t\\t\"));\n  Serial.println(pHub-&gt;bPwrOn2PwrGood, HEX);\n\n  printProgStr(PSTR(\"bHubContrCurrent:\\t\"));\n  Serial.println(pHub-&gt;bHubContrCurrent, HEX);\n\n  for (uint8_t i = 7; i &lt; len; i++)\n    print_hex(descrptr[i], 8);\n\n  //for (uint8_t i=1; i&lt;=pHub-&gt;bNbrPorts; i++)\n  //    PrintHubPortStatus(&amp;Usb, addr, i, 1);\n}\n\nuint8_t getconfdescr( uint8_t addr, uint8_t conf )\n{\n  uint8_t buf[ BUFSIZE ];\n  uint8_t* buf_ptr = buf;\n  uint8_t rcode;\n  uint8_t descr_length;\n  uint8_t descr_type;\n  uint16_t total_length;\n  rcode = Usb.getConfDescr( addr, 0, 4, conf, buf );  //get total length\n  LOBYTE( total_length ) = buf[ 2 ];\n  HIBYTE( total_length ) = buf[ 3 ];\n  if ( total_length &gt; 256 ) {   //check if total length is larger than buffer\n    printProgStr(Conf_Trunc_str);\n    total_length = 256;\n  }\n  rcode = Usb.getConfDescr( addr, 0, total_length, conf, buf ); //get the whole descriptor\n  while ( buf_ptr &lt; buf + total_length ) { //parsing descriptors\n    descr_length = *( buf_ptr );\n    descr_type = *( buf_ptr + 1 );\n    switch ( descr_type ) {\n      case ( USB_DESCRIPTOR_CONFIGURATION ):\n        printconfdescr( buf_ptr );\n        break;\n      case ( USB_DESCRIPTOR_INTERFACE ):\n        printintfdescr( buf_ptr );\n        break;\n      case ( USB_DESCRIPTOR_ENDPOINT ):\n        printepdescr( buf_ptr );\n        break;\n      case 0x29:\n        printhubdescr( buf_ptr, addr );\n        break;\n      default:\n        printunkdescr( buf_ptr );\n        break;\n    }//switch( descr_type\n    buf_ptr = ( buf_ptr + descr_length );    //advance buffer pointer\n  }//while( buf_ptr &lt;=...\n  return ( rcode );\n}\n/* prints hex numbers with leading zeroes */\n// copyright, Peter H Anderson, Baltimore, MD, Nov, '07\n// source: http://www.phanderson.com/arduino/arduino_display.html\nvoid print_hex(int v, int num_places)\n{\n  int mask = 0, n, num_nibbles, digit;\n\n  for (n = 1; n &lt;= num_places; n++) {\n    mask = (mask &lt;&lt; 1) | 0x0001;\n  }\n  v = v &amp; mask; // truncate v to specified number of places\n\n  num_nibbles = num_places / 4;\n  if ((num_places % 4) != 0) {\n    ++num_nibbles;\n  }\n  do {\n    digit = ((v &gt;&gt; (num_nibbles - 1) * 4)) &amp; 0x0f;\n    Serial.print(digit, HEX);\n  }\n  while (--num_nibbles);\n}\n/* function to print configuration descriptor */\nvoid printconfdescr( uint8_t* descr_ptr )\n{\n  USB_CONFIGURATION_DESCRIPTOR* conf_ptr = ( USB_CONFIGURATION_DESCRIPTOR* )descr_ptr;\n  printProgStr(Conf_Header_str);\n  printProgStr(Conf_Totlen_str);\n  print_hex( conf_ptr-&gt;wTotalLength, 16 );\n  printProgStr(Conf_Nint_str);\n  print_hex( conf_ptr-&gt;bNumInterfaces, 8 );\n  printProgStr(Conf_Value_str);\n  print_hex( conf_ptr-&gt;bConfigurationValue, 8 );\n  printProgStr(Conf_String_str);\n  print_hex( conf_ptr-&gt;iConfiguration, 8 );\n  printProgStr(Conf_Attr_str);\n  print_hex( conf_ptr-&gt;bmAttributes, 8 );\n  printProgStr(Conf_Pwr_str);\n  print_hex( conf_ptr-&gt;bMaxPower, 8 );\n  return;\n}\n/* function to print interface descriptor */\nvoid printintfdescr( uint8_t* descr_ptr )\n{\n  USB_INTERFACE_DESCRIPTOR* intf_ptr = ( USB_INTERFACE_DESCRIPTOR* )descr_ptr;\n  printProgStr(Int_Header_str);\n  printProgStr(Int_Number_str);\n  print_hex( intf_ptr-&gt;bInterfaceNumber, 8 );\n  printProgStr(Int_Alt_str);\n  print_hex( intf_ptr-&gt;bAlternateSetting, 8 );\n  printProgStr(Int_Endpoints_str);\n  print_hex( intf_ptr-&gt;bNumEndpoints, 8 );\n  printProgStr(Int_Class_str);\n  print_hex( intf_ptr-&gt;bInterfaceClass, 8 );\n  printProgStr(Int_Subclass_str);\n  print_hex( intf_ptr-&gt;bInterfaceSubClass, 8 );\n  printProgStr(Int_Protocol_str);\n  print_hex( intf_ptr-&gt;bInterfaceProtocol, 8 );\n  printProgStr(Int_String_str);\n  print_hex( intf_ptr-&gt;iInterface, 8 );\n  return;\n}\n/* function to print endpoint descriptor */\nvoid printepdescr( uint8_t* descr_ptr )\n{\n  USB_ENDPOINT_DESCRIPTOR* ep_ptr = ( USB_ENDPOINT_DESCRIPTOR* )descr_ptr;\n  printProgStr(End_Header_str);\n  printProgStr(End_Address_str);\n  print_hex( ep_ptr-&gt;bEndpointAddress, 8 );\n  printProgStr(End_Attr_str);\n  print_hex( ep_ptr-&gt;bmAttributes, 8 );\n  printProgStr(End_Pktsize_str);\n  print_hex( ep_ptr-&gt;wMaxPacketSize, 16 );\n  printProgStr(End_Interval_str);\n  print_hex( ep_ptr-&gt;bInterval, 8 );\n\n  return;\n}\n/*function to print unknown descriptor */\nvoid printunkdescr( uint8_t* descr_ptr )\n{\n  uint8_t length = *descr_ptr;\n  uint8_t i;\n  printProgStr(Unk_Header_str);\n  printProgStr(Unk_Length_str);\n  print_hex( *descr_ptr, 8 );\n  printProgStr(Unk_Type_str);\n  print_hex( *(descr_ptr + 1 ), 8 );\n  printProgStr(Unk_Contents_str);\n  descr_ptr += 2;\n  for ( i = 0; i &lt; length; i++ ) {\n    print_hex( *descr_ptr, 8 );\n    descr_ptr++;\n  }\n}\n\n\n/* Print a string from Program Memory directly to save RAM */\nvoid printProgStr(const char* str)\n{\n  char c;\n  if (!str) return;\n  while ((c = pgm_read_byte(str++)))\n    Serial.print(c);\n}\n</code></pre> <pre><code>#if !defined(__PGMSTRINGS_H__)\n#define __PGMSTRINGS_H__\n\n#define LOBYTE(x) ((char*)(&amp;(x)))[0]\n#define HIBYTE(x) ((char*)(&amp;(x)))[1]\n#define BUFSIZE 256    //buffer size\n\n\n/* Print strings in Program Memory */\nconst char Gen_Error_str[] PROGMEM = \"\\r\\nRequest error. Error code:\\t\"; \nconst char Dev_Header_str[] PROGMEM =\"\\r\\nDevice descriptor: \";\nconst char Dev_Length_str[] PROGMEM =\"\\r\\nDescriptor Length:\\t\";\nconst char Dev_Type_str[] PROGMEM =\"\\r\\nDescriptor type:\\t\";\nconst char Dev_Version_str[] PROGMEM =\"\\r\\nUSB version:\\t\\t\";\nconst char Dev_Class_str[] PROGMEM =\"\\r\\nDevice class:\\t\\t\";\nconst char Dev_Subclass_str[] PROGMEM =\"\\r\\nDevice Subclass:\\t\";\nconst char Dev_Protocol_str[] PROGMEM =\"\\r\\nDevice Protocol:\\t\";\nconst char Dev_Pktsize_str[] PROGMEM =\"\\r\\nMax.packet size:\\t\";\nconst char Dev_Vendor_str[] PROGMEM =\"\\r\\nVendor  ID:\\t\\t\";\nconst char Dev_Product_str[] PROGMEM =\"\\r\\nProduct ID:\\t\\t\";\nconst char Dev_Revision_str[] PROGMEM =\"\\r\\nRevision ID:\\t\\t\";\nconst char Dev_Mfg_str[] PROGMEM =\"\\r\\nMfg.string index:\\t\";\nconst char Dev_Prod_str[] PROGMEM =\"\\r\\nProd.string index:\\t\";\nconst char Dev_Serial_str[] PROGMEM =\"\\r\\nSerial number index:\\t\";\nconst char Dev_Nconf_str[] PROGMEM =\"\\r\\nNumber of conf.:\\t\";\nconst char Conf_Trunc_str[] PROGMEM =\"Total length truncated to 256 bytes\";\nconst char Conf_Header_str[] PROGMEM =\"\\r\\nConfiguration descriptor:\";\nconst char Conf_Totlen_str[] PROGMEM =\"\\r\\nTotal length:\\t\\t\";\nconst char Conf_Nint_str[] PROGMEM =\"\\r\\nNum.intf:\\t\\t\";\nconst char Conf_Value_str[] PROGMEM =\"\\r\\nConf.value:\\t\\t\";\nconst char Conf_String_str[] PROGMEM =\"\\r\\nConf.string:\\t\\t\";\nconst char Conf_Attr_str[] PROGMEM =\"\\r\\nAttr.:\\t\\t\\t\";\nconst char Conf_Pwr_str[] PROGMEM =\"\\r\\nMax.pwr:\\t\\t\";\nconst char Int_Header_str[] PROGMEM =\"\\r\\n\\r\\nInterface descriptor:\";\nconst char Int_Number_str[] PROGMEM =\"\\r\\nIntf.number:\\t\\t\";\nconst char Int_Alt_str[] PROGMEM =\"\\r\\nAlt.:\\t\\t\\t\";\nconst char Int_Endpoints_str[] PROGMEM =\"\\r\\nEndpoints:\\t\\t\";\nconst char Int_Class_str[] PROGMEM =\"\\r\\nIntf. Class:\\t\\t\";\nconst char Int_Subclass_str[] PROGMEM =\"\\r\\nIntf. Subclass:\\t\\t\";\nconst char Int_Protocol_str[] PROGMEM =\"\\r\\nIntf. Protocol:\\t\\t\";\nconst char Int_String_str[] PROGMEM =\"\\r\\nIntf.string:\\t\\t\";\nconst char End_Header_str[] PROGMEM =\"\\r\\n\\r\\nEndpoint descriptor:\";\nconst char End_Address_str[] PROGMEM =\"\\r\\nEndpoint address:\\t\";\nconst char End_Attr_str[] PROGMEM =\"\\r\\nAttr.:\\t\\t\\t\";\nconst char End_Pktsize_str[] PROGMEM =\"\\r\\nMax.pkt size:\\t\\t\";\nconst char End_Interval_str[] PROGMEM =\"\\r\\nPolling interval:\\t\";\nconst char Unk_Header_str[] PROGMEM = \"\\r\\nUnknown descriptor:\";\nconst char Unk_Length_str[] PROGMEM =\"\\r\\nLength:\\t\\t\";\nconst char Unk_Type_str[] PROGMEM =\"\\r\\nType:\\t\\t\";\nconst char Unk_Contents_str[] PROGMEM =\"\\r\\nContents:\\t\";\n\n#endif // __PGMSTRINGS_H__\n</code></pre> <p>Users will need to connect a peripheral USB device to the USB-C connector, before running the example. After the example begins, users should see an output in the Serial Monitor with a description of the connected USB device.</p> <p></p> <p>The USB Host Shield with a USB-C adapter and flash drive attached.</p> USB Hubs <p>If users connect USB hubs or USB cables with a hub to the USB host shield, utilize the hub_demo example from the USB_Host_Shield_2.0 Arduino library instead. This example can be found in the File dropdown menu (i.e. File &gt; Examples &gt; USB Host Shield Library 2.0 &gt; hub_demo) and will list the USB description for the hub(s) and all the peripheral devices connected to the hub(s).</p> Only interested in the USB hub description? <p>To see just the USB description for the hub(s) connected to the USB host shield, follow the information in the library's FAQ. Utilizing the USB_dec example, uncomment lines 12-18(1).</p> <ol> <li>Each instance of <code>USBHub Hub&lt;number&gt;(&amp;Usb);</code> enables a USB hub, but the library is limited up to seven USB hubs. </li> </ol> USB_desc.ino<pre><code>USB     Usb;\n//USBHub  Hub1(&amp;Usb);\n//USBHub  Hub2(&amp;Usb);\n//USBHub  Hub3(&amp;Usb);\n//USBHub  Hub4(&amp;Usb);\n//USBHub  Hub5(&amp;Usb);\n//USBHub  Hub6(&amp;Usb);\n//USBHub  Hub7(&amp;Usb);\n</code></pre> <ul> <li> <p>Qwiic USB Hub - USB2514B     SPX-18014 <p> </p> <li> <p>SparkFun 4-in-1 Multi-USB Cable - USB-C Host     CAB-21271 <p> </p> <li> <p>SparkFun 4-in-1 Multi-USB Cable - USB-A Host     CAB-21272 <p> </p>"},{"location":"example-usb_hid/","title":"Keyboard & Mouse","text":""},{"location":"example-usb_hid/#hid-keyboard-and-mouse","title":"HID Keyboard and Mouse","text":"<p>In this example, we will be utilizing the USBHIDBootKbdAndMouse example from the USB_Host_Shield_2.0 Arduino library. This example can be found in the File dropdown menu (i.e. (1) File &gt; Examples &gt; USB Host Shield Library 2.0 &gt; HID &gt; USBHIDBootKbdAndMouse). Once the example has been opened, users should see the <code>USBHIDBootKbdAndMouse.ino</code> example sketch.</p> <ol> <li> Select the <code>USBHIDBootKbdAndMouse</code> example sketch from the <code>File</code> drop-down menu. </li> </ol> USBHIDBootKbdAndMouse.ino <pre><code>#include &lt;hidboot.h&gt;\n#include &lt;usbhub.h&gt;\n\n// Satisfy IDE, which only needs to see the include statment in the ino.\n#ifdef dobogusinclude\n#include &lt;spi4teensy3.h&gt;\n#endif\n#include &lt;SPI.h&gt;\n\nclass MouseRptParser : public MouseReportParser\n{\n  protected:\n    void OnMouseMove(MOUSEINFO *mi);\n    void OnLeftButtonUp(MOUSEINFO *mi);\n    void OnLeftButtonDown(MOUSEINFO *mi);\n    void OnRightButtonUp(MOUSEINFO *mi);\n    void OnRightButtonDown(MOUSEINFO *mi);\n    void OnMiddleButtonUp(MOUSEINFO *mi);\n    void OnMiddleButtonDown(MOUSEINFO *mi);\n};\nvoid MouseRptParser::OnMouseMove(MOUSEINFO *mi)\n{\n  Serial.print(\"dx=\");\n  Serial.print(mi-&gt;dX, DEC);\n  Serial.print(\" dy=\");\n  Serial.println(mi-&gt;dY, DEC);\n};\nvoid MouseRptParser::OnLeftButtonUp (MOUSEINFO *mi)\n{\n  Serial.println(\"L Butt Up\");\n};\nvoid MouseRptParser::OnLeftButtonDown   (MOUSEINFO *mi)\n{\n  Serial.println(\"L Butt Dn\");\n};\nvoid MouseRptParser::OnRightButtonUp    (MOUSEINFO *mi)\n{\n  Serial.println(\"R Butt Up\");\n};\nvoid MouseRptParser::OnRightButtonDown  (MOUSEINFO *mi)\n{\n  Serial.println(\"R Butt Dn\");\n};\nvoid MouseRptParser::OnMiddleButtonUp   (MOUSEINFO *mi)\n{\n  Serial.println(\"M Butt Up\");\n};\nvoid MouseRptParser::OnMiddleButtonDown (MOUSEINFO *mi)\n{\n  Serial.println(\"M Butt Dn\");\n};\n\nclass KbdRptParser : public KeyboardReportParser\n{\n    void PrintKey(uint8_t mod, uint8_t key);\n\n  protected:\n    void OnControlKeysChanged(uint8_t before, uint8_t after);\n    void OnKeyDown  (uint8_t mod, uint8_t key);\n    void OnKeyUp    (uint8_t mod, uint8_t key);\n    void OnKeyPressed(uint8_t key);\n};\n\nvoid KbdRptParser::PrintKey(uint8_t m, uint8_t key)\n{\n  MODIFIERKEYS mod;\n  *((uint8_t*)&amp;mod) = m;\n  Serial.print((mod.bmLeftCtrl   == 1) ? \"C\" : \" \");\n  Serial.print((mod.bmLeftShift  == 1) ? \"S\" : \" \");\n  Serial.print((mod.bmLeftAlt    == 1) ? \"A\" : \" \");\n  Serial.print((mod.bmLeftGUI    == 1) ? \"G\" : \" \");\n\n  Serial.print(\" &gt;\");\n  PrintHex&lt;uint8_t&gt;(key, 0x80);\n  Serial.print(\"&lt; \");\n\n  Serial.print((mod.bmRightCtrl   == 1) ? \"C\" : \" \");\n  Serial.print((mod.bmRightShift  == 1) ? \"S\" : \" \");\n  Serial.print((mod.bmRightAlt    == 1) ? \"A\" : \" \");\n  Serial.println((mod.bmRightGUI    == 1) ? \"G\" : \" \");\n};\n\nvoid KbdRptParser::OnKeyDown(uint8_t mod, uint8_t key)\n{\n  Serial.print(\"DN \");\n  PrintKey(mod, key);\n  uint8_t c = OemToAscii(mod, key);\n\n  if (c)\n    OnKeyPressed(c);\n}\n\nvoid KbdRptParser::OnControlKeysChanged(uint8_t before, uint8_t after) {\n\n  MODIFIERKEYS beforeMod;\n  *((uint8_t*)&amp;beforeMod) = before;\n\n  MODIFIERKEYS afterMod;\n  *((uint8_t*)&amp;afterMod) = after;\n\n  if (beforeMod.bmLeftCtrl != afterMod.bmLeftCtrl) {\n    Serial.println(\"LeftCtrl changed\");\n  }\n  if (beforeMod.bmLeftShift != afterMod.bmLeftShift) {\n    Serial.println(\"LeftShift changed\");\n  }\n  if (beforeMod.bmLeftAlt != afterMod.bmLeftAlt) {\n    Serial.println(\"LeftAlt changed\");\n  }\n  if (beforeMod.bmLeftGUI != afterMod.bmLeftGUI) {\n    Serial.println(\"LeftGUI changed\");\n  }\n\n  if (beforeMod.bmRightCtrl != afterMod.bmRightCtrl) {\n    Serial.println(\"RightCtrl changed\");\n  }\n  if (beforeMod.bmRightShift != afterMod.bmRightShift) {\n    Serial.println(\"RightShift changed\");\n  }\n  if (beforeMod.bmRightAlt != afterMod.bmRightAlt) {\n    Serial.println(\"RightAlt changed\");\n  }\n  if (beforeMod.bmRightGUI != afterMod.bmRightGUI) {\n    Serial.println(\"RightGUI changed\");\n  }\n\n}\n\nvoid KbdRptParser::OnKeyUp(uint8_t mod, uint8_t key)\n{\n  Serial.print(\"UP \");\n  PrintKey(mod, key);\n}\n\nvoid KbdRptParser::OnKeyPressed(uint8_t key)\n{\n  Serial.print(\"ASCII: \");\n  Serial.println((char)key);\n};\n\nUSB     Usb;\nUSBHub     Hub(&amp;Usb);\n\nHIDBoot &lt; USB_HID_PROTOCOL_KEYBOARD | USB_HID_PROTOCOL_MOUSE &gt; HidComposite(&amp;Usb);\nHIDBoot&lt;USB_HID_PROTOCOL_KEYBOARD&gt;    HidKeyboard(&amp;Usb);\nHIDBoot&lt;USB_HID_PROTOCOL_MOUSE&gt;    HidMouse(&amp;Usb);\n\nKbdRptParser KbdPrs;\nMouseRptParser MousePrs;\n\nvoid setup()\n{\n  Serial.begin( 115200 );\n#if !defined(__MIPSEL__)\n  while (!Serial); // Wait for serial port to connect - used on Leonardo, Teensy and other boards with built-in USB CDC serial connection\n#endif\n  Serial.println(\"Start\");\n\n  if (Usb.Init() == -1)\n    Serial.println(\"OSC did not start.\");\n\n  delay( 200 );\n\n  HidComposite.SetReportParser(0, &amp;KbdPrs);\n  HidComposite.SetReportParser(1, &amp;MousePrs);\n  HidKeyboard.SetReportParser(0, &amp;KbdPrs);\n  HidMouse.SetReportParser(0, &amp;MousePrs);\n}\n\nvoid loop()\n{\n  Usb.Task();\n}\n</code></pre> <p>Users will need to connect an HID device (keyboard and/or mouse) to the USB-C host shield with a USB cable, before running the example. After the example begins, users should see an output in the Serial Monitor with print out based on the user's interaction with their HID device.</p>"},{"location":"example-usb_hid_controller/","title":"Game Controller","text":""},{"location":"example-usb_hid_controller/#hid-game-controller","title":"HID Game Controller","text":"<p>In these examples, we will be connecting the 8BitDo SN30 Pro to the USB-C host shield. Users will need the following items for the examples below:</p> <ul> <li> 8BitDo SN30 Pro Bluetooth Gamepad   For instructions on how to use the 8BitDo SN30 Pro, please refer to their user manual.   </li> <li>USB 2.0 Type-C Cable - 1 Meter</li> <li>USB A (Female) to Type C (Male) Converter</li> <li>Bluetooth USB Module Mini</li> </ul> <ul> <li> <p>8BitDo SN30 Pro Bluetooth Gamepad     WIG-17264 <p> </p> 8BitDo SN30 Pro Manual <p>For instructions on how to use the 8BitDo SN30 Pro, please refer to their user manual.</p> <li> <p>USB 2.0 Type-C Cable - 1 Meter     CAB-16905 <p> (Coming Soon) </p> <li> <p>USB A (Female) to Type C (Male) Converter     COM-21870 <p> </p> <li> <p>Bluetooth USB Module Mini     WRL-09434 <p> </p>"},{"location":"example-usb_hid_controller/#usb-connection","title":"USB Connection","text":"<p>In this example, we will be utilizing the XBOXUSB example from the USB_Host_Shield_2.0 Arduino library. This example can be found in the File dropdown menu (i.e. (1) File &gt; Examples &gt; USB Host Shield Library 2.0 &gt; Xbox &gt; XBOXUSB). Once the example has been opened, users should see the <code>XBOXUSB.ino</code> example sketch.</p> <ol> <li> Select the <code>XBOXUSB</code> example sketch from the <code>File</code> drop-down menu. </li> </ol> XBOXONE.ino <pre><code>/*\n Example sketch for the Xbox 360 USB library - developed by Kristian Lauszus\n For more information visit my blog: http://blog.tkjelectronics.dk/ or\n send me an e-mail:  kristianl@tkjelectronics.com\n */\n\n#include &lt;XBOXUSB.h&gt;\n\n// Satisfy the IDE, which needs to see the include statment in the ino too.\n#ifdef dobogusinclude\n#include &lt;spi4teensy3.h&gt;\n#endif\n#include &lt;SPI.h&gt;\n\nUSB Usb;\nXBOXUSB Xbox(&amp;Usb);\n\nvoid setup() {\n  Serial.begin(115200);\n#if !defined(__MIPSEL__)\n  while (!Serial); // Wait for serial port to connect - used on Leonardo, Teensy and other boards with built-in USB CDC serial connection\n#endif\n  if (Usb.Init() == -1) {\n    Serial.print(F(\"\\r\\nOSC did not start\"));\n    while (1); //halt\n  }\n  Serial.print(F(\"\\r\\nXBOX USB Library Started\"));\n}\nvoid loop() {\n  Usb.Task();\n  if (Xbox.Xbox360Connected) {\n    if (Xbox.getButtonPress(LT) || Xbox.getButtonPress(RT)) {\n      Serial.print(\"LT: \");\n      Serial.print(Xbox.getButtonPress(LT));\n      Serial.print(\"\\tRT: \");\n      Serial.println(Xbox.getButtonPress(RT));\n      Xbox.setRumbleOn(Xbox.getButtonPress(LT), Xbox.getButtonPress(RT));\n    } else\n      Xbox.setRumbleOn(0, 0);\n\n    if (Xbox.getAnalogHat(LeftHatX) &gt; 7500 || Xbox.getAnalogHat(LeftHatX) &lt; -7500 || Xbox.getAnalogHat(LeftHatY) &gt; 7500 || Xbox.getAnalogHat(LeftHatY) &lt; -7500 || Xbox.getAnalogHat(RightHatX) &gt; 7500 || Xbox.getAnalogHat(RightHatX) &lt; -7500 || Xbox.getAnalogHat(RightHatY) &gt; 7500 || Xbox.getAnalogHat(RightHatY) &lt; -7500) {\n      if (Xbox.getAnalogHat(LeftHatX) &gt; 7500 || Xbox.getAnalogHat(LeftHatX) &lt; -7500) {\n        Serial.print(F(\"LeftHatX: \"));\n        Serial.print(Xbox.getAnalogHat(LeftHatX));\n        Serial.print(\"\\t\");\n      }\n      if (Xbox.getAnalogHat(LeftHatY) &gt; 7500 || Xbox.getAnalogHat(LeftHatY) &lt; -7500) {\n        Serial.print(F(\"LeftHatY: \"));\n        Serial.print(Xbox.getAnalogHat(LeftHatY));\n        Serial.print(\"\\t\");\n      }\n      if (Xbox.getAnalogHat(RightHatX) &gt; 7500 || Xbox.getAnalogHat(RightHatX) &lt; -7500) {\n        Serial.print(F(\"RightHatX: \"));\n        Serial.print(Xbox.getAnalogHat(RightHatX));\n        Serial.print(\"\\t\");\n      }\n      if (Xbox.getAnalogHat(RightHatY) &gt; 7500 || Xbox.getAnalogHat(RightHatY) &lt; -7500) {\n        Serial.print(F(\"RightHatY: \"));\n        Serial.print(Xbox.getAnalogHat(RightHatY));\n      }\n      Serial.println();\n    }\n\n    if (Xbox.getButtonClick(UP)) {\n      Xbox.setLedOn(LED1);\n      Serial.println(F(\"Up\"));\n    }\n    if (Xbox.getButtonClick(DOWN)) {\n      Xbox.setLedOn(LED4);\n      Serial.println(F(\"Down\"));\n    }\n    if (Xbox.getButtonClick(LEFT)) {\n      Xbox.setLedOn(LED3);\n      Serial.println(F(\"Left\"));\n    }\n    if (Xbox.getButtonClick(RIGHT)) {\n      Xbox.setLedOn(LED2);\n      Serial.println(F(\"Right\"));\n    }\n\n    if (Xbox.getButtonClick(START)) {\n      Xbox.setLedMode(ALTERNATING);\n      Serial.println(F(\"Start\"));\n    }\n    if (Xbox.getButtonClick(BACK)) {\n      Xbox.setLedBlink(ALL);\n      Serial.println(F(\"Back\"));\n    }\n    if (Xbox.getButtonClick(L3))\n      Serial.println(F(\"L3\"));\n    if (Xbox.getButtonClick(R3))\n      Serial.println(F(\"R3\"));\n\n    if (Xbox.getButtonClick(LB))\n      Serial.println(F(\"LB\"));\n    if (Xbox.getButtonClick(RB))\n      Serial.println(F(\"RB\"));\n    if (Xbox.getButtonClick(XBOX)) {\n      Xbox.setLedMode(ROTATING);\n      Serial.println(F(\"Xbox\"));\n    }\n\n    if (Xbox.getButtonClick(A))\n      Serial.println(F(\"A\"));\n    if (Xbox.getButtonClick(B))\n      Serial.println(F(\"B\"));\n    if (Xbox.getButtonClick(X))\n      Serial.println(F(\"X\"));\n    if (Xbox.getButtonClick(Y))\n      Serial.println(F(\"Y\"));\n  }\n  delay(1);\n}\n</code></pre> <p>Users will need to turn on and connect the controller to the USB-C host shield with a USB cable, before running the example.</p> <p></p> <p>8BitDo controller connected to the USB-C Host Shield with a USB-C cable.</p> <p>Note</p> <p>To turn on the controller, press the Start+X buttons. Users should see two status LEDs blinking at the bottom of the controller.</p> <p>After the example begins, users should see an output in the Serial Monitor with print out based on the user's interaction with their controller.</p>"},{"location":"example-usb_hid_controller/#bluetooth-connection","title":"Bluetooth Connection","text":"<p>In this example, we will be utilizing the XBOXONESBT example from the USB_Host_Shield_2.0 Arduino library. This example can be found in the File dropdown menu (i.e. (1) File &gt; Examples &gt; USB Host Shield Library 2.0 &gt; Xbox &gt; XBOXONESBT). Once the example has been opened, users should see the <code>XBOXONESBT.ino</code> example sketch.</p> <ol> <li> Select the <code>XBOXONESBT</code> example sketch from the <code>File</code> drop-down menu. </li> </ol> XBOXONESBT.ino <pre><code>/*\n Example sketch for the Xbox One S Bluetooth library - developed by Kristian Sloth Lauszus\n For more information visit the Github repository: github.com/felis/USB_Host_Shield_2.0 or\n send me an e-mail:  lauszus@gmail.com\n */\n\n#include &lt;XBOXONESBT.h&gt;\n#include &lt;usbhub.h&gt;\n\n// Satisfy the IDE, which needs to see the include statement in the ino too.\n#ifdef dobogusinclude\n#include &lt;spi4teensy3.h&gt;\n#endif\n#include &lt;SPI.h&gt;\n\nUSB Usb;\n//USBHub Hub1(&amp;Usb); // Some dongles have a hub inside\nBTD Btd(&amp;Usb); // You have to create the Bluetooth Dongle instance like so\n\n/* You can create the instance of the XBOXONESBT class in two ways */\n// This will start an inquiry and then pair with the Xbox One S controller - you only have to do this once\n// You will need to hold down the Sync and Xbox button at the same time, the Xbox One S controller will then start to blink rapidly indicating that it is in pairing mode\nXBOXONESBT Xbox(&amp;Btd, PAIR);\n\n// After that you can simply create the instance like so and then press the Xbox button on the device\n//XBOXONESBT Xbox(&amp;Btd);\n\nvoid setup() {\n  Serial.begin(115200);\n#if !defined(__MIPSEL__)\n  while (!Serial); // Wait for serial port to connect - used on Leonardo, Teensy and other boards with built-in USB CDC serial connection\n#endif\n  if (Usb.Init() == -1) {\n    Serial.print(F(\"\\r\\nOSC did not start\"));\n    while (1); //halt\n  }\n  Serial.print(F(\"\\r\\nXbox One S Bluetooth Library Started\"));\n}\nvoid loop() {\n  Usb.Task();\n\n  if (Xbox.connected()) {\n    if (Xbox.getAnalogHat(LeftHatX) &gt; 7500 || Xbox.getAnalogHat(LeftHatX) &lt; -7500 || Xbox.getAnalogHat(LeftHatY) &gt; 7500 || Xbox.getAnalogHat(LeftHatY) &lt; -7500 || Xbox.getAnalogHat(RightHatX) &gt; 7500 || Xbox.getAnalogHat(RightHatX) &lt; -7500 || Xbox.getAnalogHat(RightHatY) &gt; 7500 || Xbox.getAnalogHat(RightHatY) &lt; -7500) {\n      if (Xbox.getAnalogHat(LeftHatX) &gt; 7500 || Xbox.getAnalogHat(LeftHatX) &lt; -7500) {\n        Serial.print(F(\"LeftHatX: \"));\n        Serial.print(Xbox.getAnalogHat(LeftHatX));\n        Serial.print(\"\\t\");\n      }\n      if (Xbox.getAnalogHat(LeftHatY) &gt; 7500 || Xbox.getAnalogHat(LeftHatY) &lt; -7500) {\n        Serial.print(F(\"LeftHatY: \"));\n        Serial.print(Xbox.getAnalogHat(LeftHatY));\n        Serial.print(\"\\t\");\n      }\n      if (Xbox.getAnalogHat(RightHatX) &gt; 7500 || Xbox.getAnalogHat(RightHatX) &lt; -7500) {\n        Serial.print(F(\"RightHatX: \"));\n        Serial.print(Xbox.getAnalogHat(RightHatX));\n        Serial.print(\"\\t\");\n      }\n      if (Xbox.getAnalogHat(RightHatY) &gt; 7500 || Xbox.getAnalogHat(RightHatY) &lt; -7500) {\n        Serial.print(F(\"RightHatY: \"));\n        Serial.print(Xbox.getAnalogHat(RightHatY));\n      }\n      Serial.println();\n    }\n\n    if (Xbox.getButtonPress(LT) &gt; 0 || Xbox.getButtonPress(RT) &gt; 0) {\n      if (Xbox.getButtonPress(LT) &gt; 0) {\n        Serial.print(F(\"LT: \"));\n        Serial.print(Xbox.getButtonPress(LT));\n        Serial.print(\"\\t\");\n      }\n      if (Xbox.getButtonPress(RT) &gt; 0) {\n        Serial.print(F(\"RT: \"));\n        Serial.print(Xbox.getButtonPress(RT));\n        Serial.print(\"\\t\");\n      }\n      Serial.println();\n    }\n\n    // Set rumble effect\n    static uint16_t oldLTValue, oldRTValue;\n    if (Xbox.getButtonPress(LT) != oldLTValue || Xbox.getButtonPress(RT) != oldRTValue) {\n      oldLTValue = Xbox.getButtonPress(LT);\n      oldRTValue = Xbox.getButtonPress(RT);\n      uint8_t leftRumble = map(oldLTValue, 0, 1023, 0, 255); // Map the trigger values into a byte\n      uint8_t rightRumble = map(oldRTValue, 0, 1023, 0, 255);\n      if (leftRumble &gt; 0 || rightRumble &gt; 0)\n        Xbox.setRumbleOn(leftRumble, rightRumble, leftRumble, rightRumble);\n      else\n        Xbox.setRumbleOff();\n    }\n\n    if (Xbox.getButtonClick(UP))\n      Serial.println(F(\"Up\"));\n    if (Xbox.getButtonClick(DOWN))\n      Serial.println(F(\"Down\"));\n    if (Xbox.getButtonClick(LEFT))\n      Serial.println(F(\"Left\"));\n    if (Xbox.getButtonClick(RIGHT))\n      Serial.println(F(\"Right\"));\n\n    if (Xbox.getButtonClick(VIEW))\n      Serial.println(F(\"View\"));\n    if (Xbox.getButtonClick(MENU))\n      Serial.println(F(\"Menu\"));\n    if (Xbox.getButtonClick(XBOX)) {\n      Serial.println(F(\"Xbox\"));\n      Xbox.disconnect();\n    }\n\n    if (Xbox.getButtonClick(LB))\n      Serial.println(F(\"LB\"));\n    if (Xbox.getButtonClick(RB))\n      Serial.println(F(\"RB\"));\n    if (Xbox.getButtonClick(LT))\n      Serial.println(F(\"LT\"));\n    if (Xbox.getButtonClick(RT))\n      Serial.println(F(\"RT\"));\n    if (Xbox.getButtonClick(L3))\n      Serial.println(F(\"L3\"));\n    if (Xbox.getButtonClick(R3))\n      Serial.println(F(\"R3\"));\n\n    if (Xbox.getButtonClick(A))\n      Serial.println(F(\"A\"));\n    if (Xbox.getButtonClick(B))\n      Serial.println(F(\"B\"));\n    if (Xbox.getButtonClick(X))\n      Serial.println(F(\"X\"));\n    if (Xbox.getButtonClick(Y))\n      Serial.println(F(\"Y\"));\n  }\n}\n</code></pre> <p>Users will need to connect the Bluetooth USB module to the USB-C host shield with the USB adapter before running the example. After the example begins, users should see an output in the Serial Monitor with print out based on the user's interaction with their controller.</p> <p></p> <p>Bluetooth module connected to the USB-C Host Shield; and paired with an 8BitDo controller.</p> <p>!! note     Make sure to wait until after the board restarts and executes the example, before pairing the 8BitDo controller with the Bluetooth module.</p>"},{"location":"example-usb_hid_controller/#bluetooth-pairing-the-controller","title":"Bluetooth Pairing the Controller","text":"<p>To turn on the controller, press the Start+X buttons. Users should see two status LEDs blinking at the bottom of the controller. To pair the controller, press and hold the pair button at the top of the controller, next to the USB-C connector, for 3 seconds. Once paired, the controller should vibrate.</p>"},{"location":"hardware_assembly/","title":"Hardware Assembly","text":"<p>Tip</p> <p>Users unfamiliar with using Arduino shields should refer to the Arduino Shields (v2) tutorial first.</p> <ul> <li> <p> <p>Arduino Shields v2</p>"},{"location":"hardware_assembly/#headers","title":"Headers","text":"<p>The pins for the USB Host Shield are broken out to 0.1\"-spaced pins on the outer edges of the board. When selecting headers, be sure you are aware of the functionality you need.</p> <p></p> <p>Soldering headers to the USB Host Shield.</p> <p>New to soldering?</p> <p>Check out our How to Solder: Through-Hole Soldering tutorial for a quick introduction!</p> <ul> <li> <p> <p>How to Solder: Through-Hole Soldering</p> <p>The Arduino Stackable Header Kit - R3 is a great option as it allows users to stack shields (w/ Uno/R3 footprint); with the pins still accessible through the female headers.</p> <p></p> <p>Stacking the USB Host Shield on the SparkFun RedBoard Plus.</p>"},{"location":"hardware_assembly/#usb-device","title":"USB Device","text":"<p>The USB port is utilized for the host/peripheral interface. Users only need to connect a USB device to the USB host shield or connect the shield to a computer with a USB-C cable.</p> <p></p> <p>The USB Host Shield with a USB-C adapter and flash drive attached. The shield sits on top of a RedBoard Plus connected to a computer.</p>"},{"location":"hardware_overview/","title":"Hardware Overview","text":""},{"location":"hardware_overview/#board-dimensions","title":"Board Dimensions","text":"<p>The board dimensions are illustrated in the drawing below; the listed measurements are in inches.</p> <p></p> <p>Board dimensions (PDF) for the USB Host Shield, in inches.</p> Need more measurements? <p>For more information about the board's dimensions, users can download the Eagle files for the board. These files can be opened in Eagle and additional measurements can be made with the dimensions tool.</p>  Eagle - Free Download! <p>Eagle is a CAD program for electronics that is free to use for hobbyists and students. However, it does require an account registration to utilize the software.</p> <p> Download fromAutodesk primary logo </p>  Dimensions Tool <p>This video from Autodesk demonstrates how to utilize the dimensions tool in Eagle, to include additional measurements:</p> <p> <p> <p> </p> <p></p>"},{"location":"hardware_overview/#power","title":"Power","text":"<p>The MAX3421E USB controller only requires 3.3V to operate; however, the shield (and USB-C connector) is powered entirely through either the <code>5V</code> or <code>VIN</code> pins of the connected Arduino board.</p> <p></p> <p>USB Host Shield power connections.</p> <p>Below, is a general summary of the power circuitry on the board:</p> <ul> <li><code>VIN</code> - Provides a regulated 3.3V and 5V for the shield<ul> <li>To utilize this pin, users will need to connect an external power source to the barrel jack of the Arduino board they are using.</li> </ul> </li> <li><code>5V</code> - Provides 5V and a regulated 3.3V for the shield</li> <li><code>GND</code> - The common ground or the 0V reference for the voltage supplies.</li> <li> <p><code>VBUS</code> - The voltage to the USB-C connector (5V)</p> <ul> <li>In reference to the <code>VBUS</code> net of the schematic.</li> <li>The available current is limited to what is supplied from the <code>VIN</code>/<code>5V</code> pin, up to the 750 mA threshold of the thermal fuse.</li> </ul> <p>Info</p> <p>When a PD device is connected and the voltage output drops below 4.75V, the PD device will restrict its current draw to avoid potentially damaging the DFP (downward-facing port).</p> </li> </ul> <p>For more details, users can reference the schematic and the datasheets of the individual components in the power circuitry.</p>"},{"location":"hardware_overview/#power-led","title":"Power LED","text":"<p>The red, power (<code>PWR</code>) LED will light up once 5V is supplied to the shield. For most users, it will light up when power is supplied to the connected Arduino board.</p> <p></p> <p>USB Host Shield <code>PWR</code> status LED indicator.</p>"},{"location":"hardware_overview/#power-switches","title":"Power Switches","text":"<p>There are two switches on the USB Host Shield. One provides a selectable power input for the shield (<code>VIN</code> or <code>5V</code>) and the other provides power control (on/off) to the shield and USB connector.</p> <p></p> <p>Power switches on the USB Host Shield.</p> <ul> <li>Power Select     The power select switch allows users to easily choose the power supply for the shield. This switch mostly controls how the regulated 5V output for the USB-C connector is sourced. However, both options additionally supply the regulated 3.3V for the MAX3421E USB controller.<ul> <li>VIN - Draws power through the Arduino board's <code>VIN</code> pin<ul> <li>Provides a regulated 5V output to the USB-C connector from the <code>VIN</code> pin, which is separate/isolated from the <code>5V</code> pin of the Arduino board</li> <li>Provides a regulated 3.3V output for the MAX3421E USB controller from the regulated 5V output of the <code>VIN</code> pin</li> </ul> </li> <li>5V - Draws power through the Arduino board's <code>5V</code> pin<ul> <li>Provides a 5V output to the USB-C connector from the <code>5V</code> pin of the Arduino board</li> <li>Provides a regulated 3.3V output for the MAX3421E USB controller from the <code>5V</code> pin</li> </ul> </li> </ul> </li> <li>Main Power     The main power switch controls the power input to the shield. This switch turns the shield on or off; when off, the power output to the USB-C connector is also disabled.</li> </ul>"},{"location":"hardware_overview/#usb-c-connector","title":"USB-C Connector","text":"Charging PD Devices <p>When a PD device is connected and the voltage output drops below 4.75V, the PD device will restrict its current draw to avoid potentially damaging the DFP (downward-facing port).</p> <p>The USB-C port supports limited power output at 5V. The available current is limited to what is supplied to the shield from either the <code>VIN</code> or <code>5V</code> pin, up to the 750 mA threshold of the thermal fuse.</p> <p></p> <p>USB-C connector on the USB Host Shield.</p>"},{"location":"hardware_overview/#usb-controller","title":"USB Controller","text":"<p>The MAX3421E from Maxim Integrated (now part of Analog Devices), is a USB peripheral/host controller that can be implemented as a full-speed USB peripheral or a full-/low-speed host compliant (USB specification rev 2.0). This allows for a vast collection of USB peripherals to be interfaced with an embedded system. The MAX3421E also includes eight general-purpose inputs and outputs so users can reclaim the I/O pins used for the SPI interface and gain additional ones.</p> <p> Features <ul> <li>Provides USB Host and Peripheral Functionality                     <ul> <li>USB 2.0 Specification: 12 Mbps (full-speed)</li> <li>16MB of Embedded SPI Flash Storage</li> </ul> </li> <li>Operating Voltage: 3.0 - 3.6 V</li> <li>Supply Current:                     <ul> <li>45 mA (max)</li> <li>8.7 mA (idle)</li> <li>30 - 60 \u00b5A (suspend)</li> </ul> </li> <li>SPI Clock Speed: 0 - 26 MHz</li> <li>Operating Temperature: -40 - +85 \u00b0C</li> </ul> MAX3421E chip on the USB-C Host Shield. <p></p>"},{"location":"hardware_overview/#io-pins","title":"I/O Pins","text":"<p>The MAX3421E is controlled with seven pins on the USB-C Host Shield. Additionally, the MAX3421E provides eight general-purpose inputs and outputs for users to reclaim their I/O pins and gain additional ones.</p> <ul> <li> <p> I/O pins used by the USB Host Shield. </p> </li> <li> SPI PinsI/O PinsPower Pins <ul> <li>SCK: <code>D13</code></li> <li>POCI: <code>D12</code></li> <li>PICO: <code>D11</code></li> <li>CS: <code>D10</code></li> </ul> <ul> <li>INT: <code>D9</code></li> <li>GPX: <code>D8</code></li> <li>RST: <code>D7</code></li> </ul> <ul> <li><code>VIN</code></li> <li><code>5V</code></li> <li><code>GND</code></li> </ul> Info <p>For more information about the power pins, please refer to the power section (above).</p> </li> </ul> New Feature <p>New on this shield, we have added a silkscreen indicator to mark the I/O pins used by the shield. This should help users who are stacking other shields to avoid pin conflicts without referencing the documentation. </p> <p> I/O pins that are marked on the USB Host Shield. </p>"},{"location":"hardware_overview/#spi-pins","title":"SPI Pins","text":"OSHW Compliance <p>To comply with the latest OSHW design practices, we have adopted the new SPI signal nomenclature (SDO/SDI and PICO/POCI). The terms Master and Slave are now referred to as Controller and Peripheral. The <code>MOSI</code> signal on a controller has been replaced with <code>SDO</code> or <code>PICO</code>. Please refer to this announcement on the decision to deprecate the MOSI/MISO terminology and transition to the SDO/SDI naming convention.</p> <p>The MAX3421E operates using a register set, accessed by an SPI interface at speeds up to 26MHz. Any SPI controller can add USB peripheral or host functionality using the simple 3- or 4- wire SPI interface The USB-timed operations are performed inside the MAX3421E with interrupts provided at completion, so any SPI controller does not need timers to meet USB timing requirements. Additionally, the firmware to operate the MAX3421E can also be simplified to only support a specific target device.</p> <p> SCK <code>D13</code> (<code>SCK</code>) SDI or POCI <code>D12</code> (<code>MISO</code>) SDO or PICO <code>D11</code> (<code>MOSI</code>) CS <code>D10</code> (<code>SS</code>) Default SPI bus connections on the USB Host Shield. </p> Tip <p>To learn more about the serial peripheral interface (SPI) protocol, check out this great tutorial. <p> Serial Peripheral Interface (SPI) </p></p>"},{"location":"hardware_overview/#io-pins_1","title":"I/O Pins","text":"<p>In addition to the SPI pins, there are three I/O pins for the MAX3421E.</p> <p> INT <code>D9</code> <code>(Output)</code> GPX <code>D8</code> <code>(Output)</code> RES <code>D7</code> <code>(Input)</code> I/O pins on the USB Host Shield. </p> <ul> <li> <p><code>INT</code> - Interrupt (Output)</p> <p>The MAX3421E <code>INT</code> pin outputs a signal when a USB event occurs, which requires the attention of the SPI controller. In level mode, the <code>INT</code> pin is open-drain and active low. In edge mode, the pin can be operated as push-pull output with programmable polarity. Users can enable the interrupt by setting the IE bit in the CPUCTL (R16) register. The <code>INT</code> pin can also be configured to be triggered from the general-purpose inputs (<code>GPIN0</code>\u2013<code>GPIN7</code>).</p> </li> <li> <p><code>GPX</code> - General-Purpose Multiplexed (Output)</p> <p>The MAX3421E <code>GPX</code> pin indicates one of five internal signals:</p> <ul> <li><code>OPERATE</code> - The signal is high when the MAX3421E is able to operate after a power-up or <code>RES</code> reset.</li> <li><code>VBUS_DET</code> - Provides the <code>VBCOMP</code> comparator output.</li> <li><code>BUSACT</code> - The signal is active (high), whenever there is traffic on the USB bus.</li> <li><code>INIRQ</code> -  In this mode, <code>GPIN</code> interrupts appear only on the <code>GPX</code> pin, and do not appear on the <code>INT</code> output pin.<ul> <li>When the SEPIRQ bit of the MODE (R27) register is set high, the <code>BUSACT</code> signal is removed </li> </ul> </li> <li><code>SOF</code> - A square wave is produced, with a positive edge that indicates the USB start-of-frame.</li> </ul> <p>The internal MAX3421E signal that appears on <code>GPX</code> is programmable by writing to the <code>GPXB</code> and <code>GPXA</code> bits of the PINCTL (R17) register and the <code>SEPIRQ</code> bit of the MODE (R27) register. </p> <p> GPXB GPXA GPX PIN OUTPUT 0 0 OPERATE (Default State) 0 1 VBUS_DET 1 0 BUSACT/INIRQ 1 1 SOF <p></p> <li> <p><code>RES</code> - Device Reset (Input)</p> <p>Driving the <code>RES</code> pin low causes a chip reset on the MAX3421E. In a chip reset, all registers are reset to their default states, except for PINCTL (R17), USBCTL (R15), and SPI logic. To bring the MAX3421E out of chip reset, <code>RES</code> must be driven high.</p> <p>Note</p> <p>The MAX3421E is internally reset if either V<sub>CC</sub> or V<sub>L</sub> is not present. The register file is not accessible under these conditions.</p> </li>"},{"location":"hardware_overview/#max3421e-io-pins","title":"MAX3421E I/O Pins","text":"<p>The MAX3421E also includes eight general-purpose inputs (8) and outputs (8), that can be used to reclaim the I/O pins used for the SPI interface and gain additional ones.</p> <ul> <li><code>GPOUT#</code> - General-Purpose Push-Pull Outputs.</li> <li><code>GPIN#</code> - General-Purpose Inputs.<ul> <li><code>GPIN7</code>\u2013<code>GPIN0</code> are connected to V<sub>L</sub> with internal pullup resistors.</li> </ul> </li> </ul> <p></p> <p>GPIO pins on the USB Host Shield.</p>"},{"location":"hardware_overview/#usb-c-connector_1","title":"USB-C Connector","text":"Charging PD Devices <p>When a PD device is connected and the voltage output drops below 4.75V, the PD device will restrict its current draw to avoid potentially damaging the DFP (downward-facing port).</p> <p>The USB-C connector is used to provide provided an interface to the MAX3421 USB controller, which can function as either a USB peripheral or host. It also supports limited power output at 5V. The available current is limited to what is supplied to the shield from either the <code>VIN</code> or <code>5V</code> pin, up to the 750 mA threshold of the thermal fuse.</p> <p></p> <p>USB-C connector on the USB Host Shield.</p>"},{"location":"hardware_overview/#reset-button","title":"Reset Button","text":"<p>Sometimes, an Arduino shield covers the Reset button of a user's Arduino board; therefore, a Reset button is provided on the USB-C Host shield. This allows users to easily reset their Arduino board without having to squeeze in between the Arduino board and shield to hit the button.</p> <p></p> <p>Reset button and <code>RST</code> pin on the USB Host Shield.</p> <p>Note</p> <p>The reset button (<code>RST</code> pin) is different from the <code>RES</code> (reset) pin for the MAX3421E.</p> <ul> <li>The button, <code>RST</code> pin on the shield, resets the microcontroller of the attached development board.</li> <li>The <code>RES</code> pin, connected to pin <code>7</code> on the shield, is a chip reset for the MAX3421E.</li> </ul>"},{"location":"hardware_overview/#jumper","title":"Jumper","text":"<p>There is a SHLD jumper on the top of the board that can be used to easily disconnect the shroud of the USB-C connector from <code>GND</code>.</p> New to jumper pads? <p>Check out our Jumper Pads and PCB Traces Tutorial for a quick introduction!</p> <ul> <li> <p> <p>How to Work with Jumper Pads and PCB Traces</p> <p></p> <p>The <code>SHLD</code> jumper on the top of the USB Host Shield.</p>"},{"location":"introduction/","title":"Introduction","text":"<p>Attention</p> <p>This guide is specific to the USB-C Host Shield board variant. For the variants with the USB (Type-A) connector, please refer to the hookup guide, linked here.</p> <ul> <li> <p> USB-C Host Shield SKU: DEV-21247 <p> </p> <li> <p>The SparkFun USB-C Host Shield has similar features to our previous USB Host Shield (v2), but we upgraded the USB Type-A connector to a USB-C connector. Additionally, the board provides users with the option to select either the <code>5V</code> or  <code>VIN</code> pin to power the shield and USB port.</p> <p>The SparkFun USB Host Shield contains all of the digital logic and analog circuitry necessary to implement a USB peripheral/host controller with your Arduino board. This means you could use your Arduino microcontroller to interface with and control any USB 2.0 compatible device - flash drives, digital cameras, Bluetooth dongles, and much more!</p> <p>A four-wire serial interface is used to communicate with the host controller chip, so the shield connects the Arduino's hardware SPI pins (D10-13) to the MAX3421E. While the logic-level for the shield is 3.3V, all the SPI signals are sent through a hex converter to keep the shield compatible with any 5V Arduino boards.</p> <p> \u00a0\u00a0Purchase from SparkFun  </p> </li>"},{"location":"introduction/#required-materials","title":"Required Materials","text":"<p>To get started with the USB-C Host Shield, users will need a few additional items. Users may already have some of these items, feel free to modify your cart accordingly. For users just getting started with electronics, we have linked a few tutorials to establish a foundation of knowledge to follow along with this hookup guide.</p> <ul> <li>Computer with an operating system (OS) that is compatible with all the software installation requirements.</li> <li> <p>A compatible microcontroller/Arduino board; we recommend the SparkFun RedBoard Plus.</p> <p>Warning</p> <p>The recommended Arduino library for the USB Host Shield is not compatible with all microcontrollers or boards. For a complete list of compatible microcontrollers and boards, please refer to the <code>README.md</code> file of USB Host Library Rev. 2.0.</p> </li> <li> <p>USB 3.1 Cable A to C - 3 Foot - Used to interface with the RedBoard Plus (1)</p> <ol> <li>If your computer doesn't have a USB-A slot or your microcontroller/Arduino board has a different USB connector, then choose an appropriate cable or adapter.</li> </ol> </li> <li> <p>SparkFun USB-C Host Shield</p> </li> <li> <p>USB Peripheral Device (i.e. flash drive, game controller, smartphone, etc.) (1)</p> <ol> <li>An adapter or cable may be necessary to interface with the peripheral device.</li> </ol> </li> <li> <p>Headers - Used to connect the shield to the Arduino board (1)</p> <ol> <li>Check out some of the options for the Arduino R3/Uno form factor boards below; otherwise, click here for a full selection of our available headers.</li> </ol> </li> <li> <p>Soldering Tools (1)</p> <ol> <li>Check out the soldering kit below; otherwise, click here for a full selection of our available soldering tools.</li> </ol> </li> </ul> <ul> <li> <p> <p>USB 3.1 Cable A to C - 3 Foot CAB-14743</p> <li> <p> <p>SparkFun RedBoard Plus DEV-18158</p> <li> <p> <p>SparkFun USB-C Host Shield DEV-21247</p> <li> <p> <p>Break Away Headers - Straight PRT-00116</p> <li> <p> <p>Arduino Stackable Header Kit - R3 PRT-11417</p> <p>Headers</p> <p>To attach the headers, users will need soldering equipment.</p> New to soldering? <p>Check out our How to Solder: Through-Hole Soldering tutorial for a quick introduction!</p> <ul> <li> <p> <p>How to Solder: Through-Hole Soldering</p> <ul> <li> <p> <p>Solder Lead Free - 100-gram Spool TOL-09325</p> <li> <p> <p>PINECIL Soldering Iron Kit KIT-24063</p> <li> <p> <p>Chip Quik No-Clean Flux Pen - 10mL TOL-14579</p> Jumper Modification <p>To modify the jumpers, users will need soldering equipment and/or a hobby knife.</p> <p>New to jumper pads?</p> <p>Check out our Jumper Pads and PCB Traces Tutorial for a quick introduction!</p> <ul> <li> <p> <p>How to Work with Jumper Pads and PCB Traces</p> <ul> <li> <p> <p>SparkFun Beginner Tool Kit TOL-22265</p> <li> <p> <p>Hobby Knife TOL-09200</p> <li> <p> <p>Chip Quik No-Clean Flux Pen - 10mL TOL-14579</p>"},{"location":"introduction/#arduino-examples","title":"Arduino Examples","text":"<p>The following products are used in the Arduino examples shown in this hookup guide. Users are welcome to choose other products; however, these have been tested and verified to work with the examples.</p> <ul> <li> <p> <p>USB 2.0 Type-C Cable - 1 Meter CAB-16905</p> <li> <p> <p>USB A (Female) to Type C (Male) Converter COM-21870</p> <li> <p> <p>SparkFun USB Thumb Drive (16GB) SWG-14658 </p> <li> <p> <p>Bluetooth USB Module Mini WRL-09434</p> <li> <p> <p>8BitDo SN30 Pro Bluetooth Gamepad WIG-17264</p>"},{"location":"introduction/#suggested-reading","title":"Suggested Reading","text":"<p>As a more sophisticated product, we will skip over the more fundamental tutorials (i.e. Ohm's Law and What is Electricity?). However, below are a few tutorials that may help users familiarize themselves with various aspects of the board.</p> <ul> <li> <p>Arduino Shields v2 <p> </p> <li> <p>Installing the Arduino IDE <p> </p> <li> <p>Installing an Arduino Library <p> </p> <li> <p>How to Solder: Through-Hole Soldering <p> </p> <li> <p>How to Work with Jumper Pads and PCB Traces <p> </p> <li> <p>Logic Levels <p> </p> <li> <p>Serial Peripheral Interface (SPI) <p> </p>"},{"location":"print_view/","title":"Introduction","text":"<p>Attention</p> <p>This guide is specific to the USB-C Host Shield board variant. For the variants with the USB (Type-A) connector, please refer to the hookup guide, linked here.</p> <ul> <li> <p> USB-C Host Shield SKU: DEV-21247 <p> </p> <li> <p>The SparkFun USB-C Host Shield has similar features to our previous USB Host Shield (v2), but we upgraded the USB Type-A connector to a USB-C connector. Additionally, the board provides users with the option to select either the <code>5V</code> or  <code>VIN</code> pin to power the shield and USB port.</p> <p>The SparkFun USB Host Shield contains all of the digital logic and analog circuitry necessary to implement a USB peripheral/host controller with your Arduino board. This means you could use your Arduino microcontroller to interface with and control any USB 2.0 compatible device - flash drives, digital cameras, Bluetooth dongles, and much more!</p> <p>A four-wire serial interface is used to communicate with the host controller chip, so the shield connects the Arduino's hardware SPI pins (D10-13) to the MAX3421E. While the logic-level for the shield is 3.3V, all the SPI signals are sent through a hex converter to keep the shield compatible with any 5V Arduino boards.</p> <p> \u00a0\u00a0Purchase from SparkFun  </p> </li>"},{"location":"print_view/#required-materials","title":"Required Materials","text":"<p>To get started with the USB-C Host Shield, users will need a few additional items. Users may already have some of these items, feel free to modify your cart accordingly. For users just getting started with electronics, we have linked a few tutorials to establish a foundation of knowledge to follow along with this hookup guide.</p> <ul> <li>Computer with an operating system (OS) that is compatible with all the software installation requirements.</li> <li> <p>A compatible microcontroller/Arduino board; we recommend the SparkFun RedBoard Plus.</p> <p>Warning</p> <p>The recommended Arduino library for the USB Host Shield is not compatible with all microcontrollers or boards. For a complete list of compatible microcontrollers and boards, please refer to the <code>README.md</code> file of USB Host Library Rev. 2.0.</p> </li> <li> <p>USB 3.1 Cable A to C - 3 Foot - Used to interface with the RedBoard Plus (1)</p> <ol> <li>If your computer doesn't have a USB-A slot or your microcontroller/Arduino board has a different USB connector, then choose an appropriate cable or adapter.</li> </ol> </li> <li> <p>SparkFun USB-C Host Shield</p> </li> <li> <p>USB Peripheral Device (i.e. flash drive, game controller, smartphone, etc.) (1)</p> <ol> <li>An adapter or cable may be necessary to interface with the peripheral device.</li> </ol> </li> <li> <p>Headers - Used to connect the shield to the Arduino board (1)</p> <ol> <li>Check out some of the options for the Arduino R3/Uno form factor boards below; otherwise, click here for a full selection of our available headers.</li> </ol> </li> <li> <p>Soldering Tools (1)</p> <ol> <li>Check out the soldering kit below; otherwise, click here for a full selection of our available soldering tools.</li> </ol> </li> </ul> <ul> <li> <p> <p>USB 3.1 Cable A to C - 3 Foot CAB-14743</p> <li> <p> <p>SparkFun RedBoard Plus DEV-18158</p> <li> <p> <p>SparkFun USB-C Host Shield DEV-21247</p> <li> <p> <p>Break Away Headers - Straight PRT-00116</p> <li> <p> <p>Arduino Stackable Header Kit - R3 PRT-11417</p> <p>Headers</p> <p>To attach the headers, users will need soldering equipment.</p> New to soldering? <p>Check out our How to Solder: Through-Hole Soldering tutorial for a quick introduction!</p> <ul> <li> <p> <p>How to Solder: Through-Hole Soldering</p> <ul> <li> <p> <p>Solder Lead Free - 100-gram Spool TOL-09325</p> <li> <p> <p>PINECIL Soldering Iron Kit KIT-24063</p> <li> <p> <p>Chip Quik No-Clean Flux Pen - 10mL TOL-14579</p> Jumper Modification <p>To modify the jumpers, users will need soldering equipment and/or a hobby knife.</p> <p>New to jumper pads?</p> <p>Check out our Jumper Pads and PCB Traces Tutorial for a quick introduction!</p> <ul> <li> <p> <p>How to Work with Jumper Pads and PCB Traces</p> <ul> <li> <p> <p>SparkFun Beginner Tool Kit TOL-22265</p> <li> <p> <p>Hobby Knife TOL-09200</p> <li> <p> <p>Chip Quik No-Clean Flux Pen - 10mL TOL-14579</p>"},{"location":"print_view/#arduino-examples","title":"Arduino Examples","text":"<p>The following products are used in the Arduino examples shown in this hookup guide. Users are welcome to choose other products; however, these have been tested and verified to work with the examples.</p> <ul> <li> <p> <p>USB 2.0 Type-C Cable - 1 Meter CAB-16905</p> <li> <p> <p>USB A (Female) to Type C (Male) Converter COM-21870</p> <li> <p> <p>SparkFun USB Thumb Drive (16GB) SWG-14658 </p> <li> <p> <p>Bluetooth USB Module Mini WRL-09434</p> <li> <p> <p>8BitDo SN30 Pro Bluetooth Gamepad WIG-17264</p>"},{"location":"print_view/#suggested-reading","title":"Suggested Reading","text":"<p>As a more sophisticated product, we will skip over the more fundamental tutorials (i.e. Ohm's Law and What is Electricity?). However, below are a few tutorials that may help users familiarize themselves with various aspects of the board.</p> <ul> <li> <p>Arduino Shields v2 <p> </p> <li> <p>Installing the Arduino IDE <p> </p> <li> <p>Installing an Arduino Library <p> </p> <li> <p>How to Solder: Through-Hole Soldering <p> </p> <li> <p>How to Work with Jumper Pads and PCB Traces <p> </p> <li> <p>Logic Levels <p> </p> <li> <p>Serial Peripheral Interface (SPI) <p> </p>"},{"location":"print_view/#hardware-overview","title":"Hardware Overview","text":""},{"location":"print_view/#board-dimensions","title":"Board Dimensions","text":"<p>The board dimensions are illustrated in the drawing below; the listed measurements are in inches.</p> <p></p> <p>Board dimensions (PDF) for the USB Host Shield, in inches.</p> Need more measurements? <p>For more information about the board's dimensions, users can download the Eagle files for the board. These files can be opened in Eagle and additional measurements can be made with the dimensions tool.</p>  Eagle - Free Download! <p>Eagle is a CAD program for electronics that is free to use for hobbyists and students. However, it does require an account registration to utilize the software.</p> <p> Download fromAutodesk primary logo </p>  Dimensions Tool <p>This video from Autodesk demonstrates how to utilize the dimensions tool in Eagle, to include additional measurements:</p> <p> <p> <p> </p> <p></p>"},{"location":"print_view/#power","title":"Power","text":"<p>The MAX3421E USB controller only requires 3.3V to operate; however, the shield (and USB-C connector) is powered entirely through either the <code>5V</code> or <code>VIN</code> pins of the connected Arduino board.</p> <p></p> <p>USB Host Shield power connections.</p> <p>Below, is a general summary of the power circuitry on the board:</p> <ul> <li><code>VIN</code> - Provides a regulated 3.3V and 5V for the shield<ul> <li>To utilize this pin, users will need to connect an external power source to the barrel jack of the Arduino board they are using.</li> </ul> </li> <li><code>5V</code> - Provides 5V and a regulated 3.3V for the shield</li> <li><code>GND</code> - The common ground or the 0V reference for the voltage supplies.</li> <li> <p><code>VBUS</code> - The voltage to the USB-C connector (5V)</p> <ul> <li>In reference to the <code>VBUS</code> net of the schematic.</li> <li>The available current is limited to what is supplied from the <code>VIN</code>/<code>5V</code> pin, up to the 750 mA threshold of the thermal fuse.</li> </ul> <p>Info</p> <p>When a PD device is connected and the voltage output drops below 4.75V, the PD device will restrict its current draw to avoid potentially damaging the DFP (downward-facing port).</p> </li> </ul> <p>For more details, users can reference the schematic and the datasheets of the individual components in the power circuitry.</p>"},{"location":"print_view/#power-led","title":"Power LED","text":"<p>The red, power (<code>PWR</code>) LED will light up once 5V is supplied to the shield. For most users, it will light up when power is supplied to the connected Arduino board.</p> <p></p> <p>USB Host Shield <code>PWR</code> status LED indicator.</p>"},{"location":"print_view/#power-switches","title":"Power Switches","text":"<p>There are two switches on the USB Host Shield. One provides a selectable power input for the shield (<code>VIN</code> or <code>5V</code>) and the other provides power control (on/off) to the shield and USB connector.</p> <p></p> <p>Power switches on the USB Host Shield.</p> <ul> <li>Power Select     The power select switch allows users to easily choose the power supply for the shield. This switch mostly controls how the regulated 5V output for the USB-C connector is sourced. However, both options additionally supply the regulated 3.3V for the MAX3421E USB controller.<ul> <li>VIN - Draws power through the Arduino board's <code>VIN</code> pin<ul> <li>Provides a regulated 5V output to the USB-C connector from the <code>VIN</code> pin, which is separate/isolated from the <code>5V</code> pin of the Arduino board</li> <li>Provides a regulated 3.3V output for the MAX3421E USB controller from the regulated 5V output of the <code>VIN</code> pin</li> </ul> </li> <li>5V - Draws power through the Arduino board's <code>5V</code> pin<ul> <li>Provides a 5V output to the USB-C connector from the <code>5V</code> pin of the Arduino board</li> <li>Provides a regulated 3.3V output for the MAX3421E USB controller from the <code>5V</code> pin</li> </ul> </li> </ul> </li> <li>Main Power     The main power switch controls the power input to the shield. This switch turns the shield on or off; when off, the power output to the USB-C connector is also disabled.</li> </ul>"},{"location":"print_view/#usb-c-connector","title":"USB-C Connector","text":"Charging PD Devices <p>When a PD device is connected and the voltage output drops below 4.75V, the PD device will restrict its current draw to avoid potentially damaging the DFP (downward-facing port).</p> <p>The USB-C port supports limited power output at 5V. The available current is limited to what is supplied to the shield from either the <code>VIN</code> or <code>5V</code> pin, up to the 750 mA threshold of the thermal fuse.</p> <p></p> <p>USB-C connector on the USB Host Shield.</p>"},{"location":"print_view/#usb-controller","title":"USB Controller","text":"<p>The MAX3421E from Maxim Integrated (now part of Analog Devices), is a USB peripheral/host controller that can be implemented as a full-speed USB peripheral or a full-/low-speed host compliant (USB specification rev 2.0). This allows for a vast collection of USB peripherals to be interfaced with an embedded system. The MAX3421E also includes eight general-purpose inputs and outputs so users can reclaim the I/O pins used for the SPI interface and gain additional ones.</p> <p> Features <ul> <li>Provides USB Host and Peripheral Functionality                     <ul> <li>USB 2.0 Specification: 12 Mbps (full-speed)</li> <li>16MB of Embedded SPI Flash Storage</li> </ul> </li> <li>Operating Voltage: 3.0 - 3.6 V</li> <li>Supply Current:                     <ul> <li>45 mA (max)</li> <li>8.7 mA (idle)</li> <li>30 - 60 \u00b5A (suspend)</li> </ul> </li> <li>SPI Clock Speed: 0 - 26 MHz</li> <li>Operating Temperature: -40 - +85 \u00b0C</li> </ul> MAX3421E chip on the USB-C Host Shield. <p></p>"},{"location":"print_view/#io-pins","title":"I/O Pins","text":"<p>The MAX3421E is controlled with seven pins on the USB-C Host Shield. Additionally, the MAX3421E provides eight general-purpose inputs and outputs for users to reclaim their I/O pins and gain additional ones.</p> <ul> <li> <p> I/O pins used by the USB Host Shield. </p> </li> <li> SPI PinsI/O PinsPower Pins <ul> <li>SCK: <code>D13</code></li> <li>POCI: <code>D12</code></li> <li>PICO: <code>D11</code></li> <li>CS: <code>D10</code></li> </ul> <ul> <li>INT: <code>D9</code></li> <li>GPX: <code>D8</code></li> <li>RST: <code>D7</code></li> </ul> <ul> <li><code>VIN</code></li> <li><code>5V</code></li> <li><code>GND</code></li> </ul> Info <p>For more information about the power pins, please refer to the power section (above).</p> </li> </ul> New Feature <p>New on this shield, we have added a silkscreen indicator to mark the I/O pins used by the shield. This should help users who are stacking other shields to avoid pin conflicts without referencing the documentation. </p> <p> I/O pins that are marked on the USB Host Shield. </p>"},{"location":"print_view/#spi-pins","title":"SPI Pins","text":"OSHW Compliance <p>To comply with the latest OSHW design practices, we have adopted the new SPI signal nomenclature (SDO/SDI and PICO/POCI). The terms Master and Slave are now referred to as Controller and Peripheral. The <code>MOSI</code> signal on a controller has been replaced with <code>SDO</code> or <code>PICO</code>. Please refer to this announcement on the decision to deprecate the MOSI/MISO terminology and transition to the SDO/SDI naming convention.</p> <p>The MAX3421E operates using a register set, accessed by an SPI interface at speeds up to 26MHz. Any SPI controller can add USB peripheral or host functionality using the simple 3- or 4- wire SPI interface The USB-timed operations are performed inside the MAX3421E with interrupts provided at completion, so any SPI controller does not need timers to meet USB timing requirements. Additionally, the firmware to operate the MAX3421E can also be simplified to only support a specific target device.</p> <p> SCK <code>D13</code> (<code>SCK</code>) SDI or POCI <code>D12</code> (<code>MISO</code>) SDO or PICO <code>D11</code> (<code>MOSI</code>) CS <code>D10</code> (<code>SS</code>) Default SPI bus connections on the USB Host Shield. </p> Tip <p>To learn more about the serial peripheral interface (SPI) protocol, check out this great tutorial. <p> Serial Peripheral Interface (SPI) </p></p>"},{"location":"print_view/#io-pins_1","title":"I/O Pins","text":"<p>In addition to the SPI pins, there are three I/O pins for the MAX3421E.</p> <p> INT <code>D9</code> <code>(Output)</code> GPX <code>D8</code> <code>(Output)</code> RES <code>D7</code> <code>(Input)</code> I/O pins on the USB Host Shield. </p> <ul> <li> <p><code>INT</code> - Interrupt (Output)</p> <p>The MAX3421E <code>INT</code> pin outputs a signal when a USB event occurs, which requires the attention of the SPI controller. In level mode, the <code>INT</code> pin is open-drain and active low. In edge mode, the pin can be operated as push-pull output with programmable polarity. Users can enable the interrupt by setting the IE bit in the CPUCTL (R16) register. The <code>INT</code> pin can also be configured to be triggered from the general-purpose inputs (<code>GPIN0</code>\u2013<code>GPIN7</code>).</p> </li> <li> <p><code>GPX</code> - General-Purpose Multiplexed (Output)</p> <p>The MAX3421E <code>GPX</code> pin indicates one of five internal signals:</p> <ul> <li><code>OPERATE</code> - The signal is high when the MAX3421E is able to operate after a power-up or <code>RES</code> reset.</li> <li><code>VBUS_DET</code> - Provides the <code>VBCOMP</code> comparator output.</li> <li><code>BUSACT</code> - The signal is active (high), whenever there is traffic on the USB bus.</li> <li><code>INIRQ</code> -  In this mode, <code>GPIN</code> interrupts appear only on the <code>GPX</code> pin, and do not appear on the <code>INT</code> output pin.<ul> <li>When the SEPIRQ bit of the MODE (R27) register is set high, the <code>BUSACT</code> signal is removed </li> </ul> </li> <li><code>SOF</code> - A square wave is produced, with a positive edge that indicates the USB start-of-frame.</li> </ul> <p>The internal MAX3421E signal that appears on <code>GPX</code> is programmable by writing to the <code>GPXB</code> and <code>GPXA</code> bits of the PINCTL (R17) register and the <code>SEPIRQ</code> bit of the MODE (R27) register. </p> <p> GPXB GPXA GPX PIN OUTPUT 0 0 OPERATE (Default State) 0 1 VBUS_DET 1 0 BUSACT/INIRQ 1 1 SOF <p></p> <li> <p><code>RES</code> - Device Reset (Input)</p> <p>Driving the <code>RES</code> pin low causes a chip reset on the MAX3421E. In a chip reset, all registers are reset to their default states, except for PINCTL (R17), USBCTL (R15), and SPI logic. To bring the MAX3421E out of chip reset, <code>RES</code> must be driven high.</p> <p>Note</p> <p>The MAX3421E is internally reset if either V<sub>CC</sub> or V<sub>L</sub> is not present. The register file is not accessible under these conditions.</p> </li>"},{"location":"print_view/#max3421e-io-pins","title":"MAX3421E I/O Pins","text":"<p>The MAX3421E also includes eight general-purpose inputs (8) and outputs (8), that can be used to reclaim the I/O pins used for the SPI interface and gain additional ones.</p> <ul> <li><code>GPOUT#</code> - General-Purpose Push-Pull Outputs.</li> <li><code>GPIN#</code> - General-Purpose Inputs.<ul> <li><code>GPIN7</code>\u2013<code>GPIN0</code> are connected to V<sub>L</sub> with internal pullup resistors.</li> </ul> </li> </ul> <p></p> <p>GPIO pins on the USB Host Shield.</p>"},{"location":"print_view/#usb-c-connector_1","title":"USB-C Connector","text":"Charging PD Devices <p>When a PD device is connected and the voltage output drops below 4.75V, the PD device will restrict its current draw to avoid potentially damaging the DFP (downward-facing port).</p> <p>The USB-C connector is used to provide provided an interface to the MAX3421 USB controller, which can function as either a USB peripheral or host. It also supports limited power output at 5V. The available current is limited to what is supplied to the shield from either the <code>VIN</code> or <code>5V</code> pin, up to the 750 mA threshold of the thermal fuse.</p> <p></p> <p>USB-C connector on the USB Host Shield.</p>"},{"location":"print_view/#reset-button","title":"Reset Button","text":"<p>Sometimes, an Arduino shield covers the Reset button of a user's Arduino board; therefore, a Reset button is provided on the USB-C Host shield. This allows users to easily reset their Arduino board without having to squeeze in between the Arduino board and shield to hit the button.</p> <p></p> <p>Reset button and <code>RST</code> pin on the USB Host Shield.</p> <p>Note</p> <p>The reset button (<code>RST</code> pin) is different from the <code>RES</code> (reset) pin for the MAX3421E.</p> <ul> <li>The button, <code>RST</code> pin on the shield, resets the microcontroller of the attached development board.</li> <li>The <code>RES</code> pin, connected to pin <code>7</code> on the shield, is a chip reset for the MAX3421E.</li> </ul>"},{"location":"print_view/#jumper","title":"Jumper","text":"<p>There is a SHLD jumper on the top of the board that can be used to easily disconnect the shroud of the USB-C connector from <code>GND</code>.</p> New to jumper pads? <p>Check out our Jumper Pads and PCB Traces Tutorial for a quick introduction!</p> <ul> <li> <p> <p>How to Work with Jumper Pads and PCB Traces</p> <p></p> <p>The <code>SHLD</code> jumper on the top of the USB Host Shield.</p>"},{"location":"print_view/#hardware-assembly","title":"Hardware Assembly","text":"<p>Tip</p> <p>Users unfamiliar with using Arduino shields should refer to the Arduino Shields (v2) tutorial first.</p> <ul> <li> <p> <p>Arduino Shields v2</p>"},{"location":"print_view/#headers","title":"Headers","text":"<p>The pins for the USB Host Shield are broken out to 0.1\"-spaced pins on the outer edges of the board. When selecting headers, be sure you are aware of the functionality you need.</p> <p></p> <p>Soldering headers to the USB Host Shield.</p> <p>New to soldering?</p> <p>Check out our How to Solder: Through-Hole Soldering tutorial for a quick introduction!</p> <ul> <li> <p> <p>How to Solder: Through-Hole Soldering</p> <p>The Arduino Stackable Header Kit - R3 is a great option as it allows users to stack shields (w/ Uno/R3 footprint); with the pins still accessible through the female headers.</p> <p></p> <p>Stacking the USB Host Shield on the SparkFun RedBoard Plus.</p>"},{"location":"print_view/#usb-device","title":"USB Device","text":"<p>The USB port is utilized for the host/peripheral interface. Users only need to connect a USB device to the USB host shield or connect the shield to a computer with a USB-C cable.</p> <p></p> <p>The USB Host Shield with a USB-C adapter and flash drive attached. The shield sits on top of a RedBoard Plus connected to a computer.</p>"},{"location":"print_view/#software-overview","title":"Software Overview","text":""},{"location":"print_view/#arduino-ide","title":"Arduino IDE","text":"<p>Tip</p> <p>For first-time users, who have never programmed before and are looking to use the Arduino IDE, we recommend beginning with the SparkFun Inventor's Kit (SIK), which includes a simple board like the Arduino Uno or SparkFun RedBoard and is designed to help users get started programming with the Arduino IDE.</p> <p>Most users may already be familiar with the Arduino IDE and its use. However, for those of you who have never heard the name Arduino before, feel free to check out the Arduino website. To get started with using the Arduino IDE, check out our tutorials below:</p> <ul> <li> <p>What is an Arduino? <p> </p> <li> <p>Installing the Arduino IDE <p> </p> <li> <p>Installing an Arduino Library <p> </p> <li> <p>Installing Board Definitions in the Arduino IDE <p> </p> Need help setting up the RedBoard Plus?"},{"location":"print_view/#redboard-plus","title":"RedBoard Plus","text":"<p>The following instructions should help users get started with the RedBoard Plus. For more information about the board, please check out our hookup guide below:</p> <p> RedBoard Plus Hookup Guide </p>"},{"location":"print_view/#ch340-driver","title":"CH340 Driver","text":"<p>Users will need to install the appropriate driver for their computer to recognize the serial-to-UART chip on their board/adapter. Most of the latest operating systems will recognize the CH340C chip on the board and automatically install the required driver.</p> <p>To manually install the CH340 driver on their computer, users can download it from the WCH website. For more information, check out our How to Install CH340 Drivers Tutorial.</p> <p> How to Install CH340 Drivers </p>"},{"location":"print_view/#arduino-ide_1","title":"Arduino IDE","text":"<p>When selecting a board to program in the Arduino IDE, users should select the Arduino Uno from the Tools drop-down menu (_i.e. Tools &gt; Board &gt; Arduino AVR Boards &gt; Arduino Uno).</p> <p> Select the Arduino Uno from the Tools drop-down menu in the Arduino IDE. </p> Arduino IDE 2.x.x - Alternative Method <p>In the newest version of the Arduino IDE 2.<code>x</code>.<code>x</code>, users can also select their board (green) and port (blue) from the <code>Select Board &amp; Port</code> dropdown menu (yellow).</p> <p> Selecting the Arduino Uno and COM5 port from the Select Board &amp; Port drop-down menu in the Arduino IDE (v2.0.3). </p>"},{"location":"print_view/#usb-host-library","title":"USB Host Library","text":"<p>The USB Host Library Rev. 2.0 can be installed from the library manager in the Arduino IDE.</p> <p></p> <p>USB Host Library in the library manager of the Arduino IDE.</p> <p>Info</p> <p>For more details about the library, check out the online documentation.</p> Arduino IDE (v1.x.x) <p>In the Arduino IDE v1.x.x, the library manager will have the following appearance for the USB Host Shield library:</p> <p> USB Host Library in the library manager of the Arduino IDE (v1.x.x). </p> Alternative Libraries <p>Users are welcome to try other libraries for the MAX3421E, such as the ones listed below. However, our technical support team will only provide assistance with the USB Host Library Rev. 2.0 recommended in this hookup guide.</p> <ul> <li>Arduino-Bluetooth</li> <li>Lightweight USB Host</li> <li>MAX3421E project for STM32</li> </ul>"},{"location":"print_view/#supported-boards","title":"Supported Boards","text":"<p>For a detailed and up-to-date list of boards supported by this library, check out the <code>README.md</code> of the GitHub repository:</p> <ul> <li>All official Arduino AVR boards (Uno, Duemilanove, Mega, Mega 2560, Mega ADK, Leonardo etc.)</li> <li>Arduino Due</li> <li>Teensy (Teensy++ 1.0, Teensy 2.0, Teensy++ 2.0, Teensy 3.x, Teensy LC and Teensy 4.x)<ul> <li>For the Teensy 3.x, install this SPI library and add <code>#include &lt;spi4teensy3.h&gt;</code> to the <code>*.ino</code> sketch file.</li> </ul> </li> <li>STM32F4<ul> <li>Take a look at the following example code.</li> </ul> </li> <li>ESP8266 is supported using the ESP8266 Arduino core<ul> <li>Uses pins <code>15</code> and <code>5</code> for <code>CS</code> and <code>INT</code>, respectively.</li> <li><code>GPIO6</code> - <code>GPIO11</code> and <code>GPIO16</code> are NOT usable.</li> </ul> </li> <li>ESP32 is supported using the arduino-esp32<ul> <li><code>GPIO5</code> : <code>CS</code></li> <li><code>GPIO17</code> : <code>INT</code></li> <li><code>GPIO18</code> : <code>SCK</code></li> <li><code>GPIO19</code> : <code>POCI</code></li> <li><code>GPIO23</code> : <code>PICO</code></li> </ul> </li> </ul>"},{"location":"print_view/#io-pin-modifications","title":"I/O Pin Modifications","text":"<p>The SPI pins used by this library are dictated by SPI library for the Arduino core being utilized and cannot be changed easily. It is recommended that the default pins of the SPI library be utilized.</p> <p>However, the USB Host Library also declares its <code>CS</code> and <code>INT</code> pins. These pins can be reconfigured in the library by modifying the UsbCore.h file:</p> <pre><code>typedef MAX3421e&lt; \"CS Pin\", \"INT Pin\" &gt; MAX3421E;\n</code></pre> <p>For instance, if a user wanted to reconfigure the <code>CS</code> pin to <code>D7</code> and the <code>INT</code> pin to <code>D2</code> of the RedBoard Plus (or any other Arduino Uno/ATmega328P based board), line 58 should read:</p> <pre><code>typedef MAX3421e&lt;P7, P2&gt; MAX3421E;\n</code></pre> <p>Tip</p> <p>The information above is an example of a pin modification. However, it is not required for the general use of the shield and the examples in this guide. For more information, please refer to the instructions in the <code>README.md</code> of the GitHub repository.</p> Other Boards <p>For other boards, users will need to modify the lines based on the microcontroller type. For example, with the SparkFun IoT RedBoard users would need to modify line 52.</p>"},{"location":"print_view/#arduino-examples_1","title":"Arduino Examples","text":""},{"location":"print_view/#usb-description","title":"USB Description","text":"<p>For our first example, we will be utilizing the USB_dec example from the USB_Host_Shield_2.0 Arduino library. This example can be found in the File dropdown menu (i.e. (1) File &gt; Examples &gt; USB Host Shield Library 2.0 &gt; USB_Desc). Once the example has been opened, users should see two files <code>USB_desc.ino</code> and <code>pgmstrings.h</code>.</p> <ol> <li> Select the <code>USB_Desc</code> example sketch from the <code>File</code> drop-down menu. </li> </ol> Example Files USB_desc.inopgmstrings.h <pre><code>#include &lt;usbhub.h&gt;\n\n#include \"pgmstrings.h\"\n\n// Satisfy the IDE, which needs to see the include statment in the ino too.\n#ifdef dobogusinclude\n#include &lt;spi4teensy3.h&gt;\n#endif\n#include &lt;SPI.h&gt;\n\nUSB     Usb;\n//USBHub  Hub1(&amp;Usb);\n//USBHub  Hub2(&amp;Usb);\n//USBHub  Hub3(&amp;Usb);\n//USBHub  Hub4(&amp;Usb);\n//USBHub  Hub5(&amp;Usb);\n//USBHub  Hub6(&amp;Usb);\n//USBHub  Hub7(&amp;Usb);\n\nvoid PrintAllAddresses(UsbDevice *pdev)\n{\n  UsbDeviceAddress adr;\n  adr.devAddress = pdev-&gt;address.devAddress;\n  Serial.print(\"\\r\\nAddr:\");\n  Serial.print(adr.devAddress, HEX);\n  Serial.print(\"(\");\n  Serial.print(adr.bmHub, HEX);\n  Serial.print(\".\");\n  Serial.print(adr.bmParent, HEX);\n  Serial.print(\".\");\n  Serial.print(adr.bmAddress, HEX);\n  Serial.println(\")\");\n}\n\nvoid PrintAddress(uint8_t addr)\n{\n  UsbDeviceAddress adr;\n  adr.devAddress = addr;\n  Serial.print(\"\\r\\nADDR:\\t\");\n  Serial.println(adr.devAddress, HEX);\n  Serial.print(\"DEV:\\t\");\n  Serial.println(adr.bmAddress, HEX);\n  Serial.print(\"PRNT:\\t\");\n  Serial.println(adr.bmParent, HEX);\n  Serial.print(\"HUB:\\t\");\n  Serial.println(adr.bmHub, HEX);\n}\n\nvoid setup()\n{\n  Serial.begin( 115200 );\n#if !defined(__MIPSEL__)\n  while (!Serial); // Wait for serial port to connect - used on Leonardo, Teensy and other boards with built-in USB CDC serial connection\n#endif\n  Serial.println(\"Start\");\n\n  if (Usb.Init() == -1)\n    Serial.println(\"OSC did not start.\");\n\n  delay( 200 );\n}\n\nuint8_t getdevdescr( uint8_t addr, uint8_t &amp;num_conf );\n\nvoid PrintDescriptors(uint8_t addr)\n{\n  uint8_t rcode = 0;\n  uint8_t num_conf = 0;\n\n  rcode = getdevdescr( (uint8_t)addr, num_conf );\n  if ( rcode )\n  {\n    printProgStr(Gen_Error_str);\n    print_hex( rcode, 8 );\n  }\n  Serial.print(\"\\r\\n\");\n\n  for (int i = 0; i &lt; num_conf; i++)\n  {\n    rcode = getconfdescr( addr, i );                 // get configuration descriptor\n    if ( rcode )\n    {\n      printProgStr(Gen_Error_str);\n      print_hex(rcode, 8);\n    }\n    Serial.println(\"\\r\\n\");\n  }\n}\n\nvoid PrintAllDescriptors(UsbDevice *pdev)\n{\n  Serial.println(\"\\r\\n\");\n  print_hex(pdev-&gt;address.devAddress, 8);\n  Serial.println(\"\\r\\n--\");\n  PrintDescriptors( pdev-&gt;address.devAddress );\n}\n\nvoid loop()\n{\n  Usb.Task();\n\n  if ( Usb.getUsbTaskState() == USB_STATE_RUNNING )\n  {\n    Usb.ForEachUsbDevice(&amp;PrintAllDescriptors);\n    Usb.ForEachUsbDevice(&amp;PrintAllAddresses);\n\n    while ( 1 ) { // stop\n#ifdef ESP8266\n        yield(); // needed in order to reset the watchdog timer on the ESP8266\n#endif\n    }\n  }\n}\n\nuint8_t getdevdescr( uint8_t addr, uint8_t &amp;num_conf )\n{\n  USB_DEVICE_DESCRIPTOR buf;\n  uint8_t rcode;\n  rcode = Usb.getDevDescr( addr, 0, 0x12, ( uint8_t *)&amp;buf );\n  if ( rcode ) {\n    return ( rcode );\n  }\n  printProgStr(Dev_Header_str);\n  printProgStr(Dev_Length_str);\n  print_hex( buf.bLength, 8 );\n  printProgStr(Dev_Type_str);\n  print_hex( buf.bDescriptorType, 8 );\n  printProgStr(Dev_Version_str);\n  print_hex( buf.bcdUSB, 16 );\n  printProgStr(Dev_Class_str);\n  print_hex( buf.bDeviceClass, 8 );\n  printProgStr(Dev_Subclass_str);\n  print_hex( buf.bDeviceSubClass, 8 );\n  printProgStr(Dev_Protocol_str);\n  print_hex( buf.bDeviceProtocol, 8 );\n  printProgStr(Dev_Pktsize_str);\n  print_hex( buf.bMaxPacketSize0, 8 );\n  printProgStr(Dev_Vendor_str);\n  print_hex( buf.idVendor, 16 );\n  printProgStr(Dev_Product_str);\n  print_hex( buf.idProduct, 16 );\n  printProgStr(Dev_Revision_str);\n  print_hex( buf.bcdDevice, 16 );\n  printProgStr(Dev_Mfg_str);\n  print_hex( buf.iManufacturer, 8 );\n  printProgStr(Dev_Prod_str);\n  print_hex( buf.iProduct, 8 );\n  printProgStr(Dev_Serial_str);\n  print_hex( buf.iSerialNumber, 8 );\n  printProgStr(Dev_Nconf_str);\n  print_hex( buf.bNumConfigurations, 8 );\n  num_conf = buf.bNumConfigurations;\n  return ( 0 );\n}\n\nvoid printhubdescr(uint8_t *descrptr, uint8_t addr)\n{\n  HubDescriptor  *pHub = (HubDescriptor*) descrptr;\n  uint8_t        len = *((uint8_t*)descrptr);\n\n  printProgStr(PSTR(\"\\r\\n\\r\\nHub Descriptor:\\r\\n\"));\n  printProgStr(PSTR(\"bDescLength:\\t\\t\"));\n  Serial.println(pHub-&gt;bDescLength, HEX);\n\n  printProgStr(PSTR(\"bDescriptorType:\\t\"));\n  Serial.println(pHub-&gt;bDescriptorType, HEX);\n\n  printProgStr(PSTR(\"bNbrPorts:\\t\\t\"));\n  Serial.println(pHub-&gt;bNbrPorts, HEX);\n\n  printProgStr(PSTR(\"LogPwrSwitchMode:\\t\"));\n  Serial.println(pHub-&gt;LogPwrSwitchMode, BIN);\n\n  printProgStr(PSTR(\"CompoundDevice:\\t\\t\"));\n  Serial.println(pHub-&gt;CompoundDevice, BIN);\n\n  printProgStr(PSTR(\"OverCurrentProtectMode:\\t\"));\n  Serial.println(pHub-&gt;OverCurrentProtectMode, BIN);\n\n  printProgStr(PSTR(\"TTThinkTime:\\t\\t\"));\n  Serial.println(pHub-&gt;TTThinkTime, BIN);\n\n  printProgStr(PSTR(\"PortIndicatorsSupported:\"));\n  Serial.println(pHub-&gt;PortIndicatorsSupported, BIN);\n\n  printProgStr(PSTR(\"Reserved:\\t\\t\"));\n  Serial.println(pHub-&gt;Reserved, HEX);\n\n  printProgStr(PSTR(\"bPwrOn2PwrGood:\\t\\t\"));\n  Serial.println(pHub-&gt;bPwrOn2PwrGood, HEX);\n\n  printProgStr(PSTR(\"bHubContrCurrent:\\t\"));\n  Serial.println(pHub-&gt;bHubContrCurrent, HEX);\n\n  for (uint8_t i = 7; i &lt; len; i++)\n    print_hex(descrptr[i], 8);\n\n  //for (uint8_t i=1; i&lt;=pHub-&gt;bNbrPorts; i++)\n  //    PrintHubPortStatus(&amp;Usb, addr, i, 1);\n}\n\nuint8_t getconfdescr( uint8_t addr, uint8_t conf )\n{\n  uint8_t buf[ BUFSIZE ];\n  uint8_t* buf_ptr = buf;\n  uint8_t rcode;\n  uint8_t descr_length;\n  uint8_t descr_type;\n  uint16_t total_length;\n  rcode = Usb.getConfDescr( addr, 0, 4, conf, buf );  //get total length\n  LOBYTE( total_length ) = buf[ 2 ];\n  HIBYTE( total_length ) = buf[ 3 ];\n  if ( total_length &gt; 256 ) {   //check if total length is larger than buffer\n    printProgStr(Conf_Trunc_str);\n    total_length = 256;\n  }\n  rcode = Usb.getConfDescr( addr, 0, total_length, conf, buf ); //get the whole descriptor\n  while ( buf_ptr &lt; buf + total_length ) { //parsing descriptors\n    descr_length = *( buf_ptr );\n    descr_type = *( buf_ptr + 1 );\n    switch ( descr_type ) {\n      case ( USB_DESCRIPTOR_CONFIGURATION ):\n        printconfdescr( buf_ptr );\n        break;\n      case ( USB_DESCRIPTOR_INTERFACE ):\n        printintfdescr( buf_ptr );\n        break;\n      case ( USB_DESCRIPTOR_ENDPOINT ):\n        printepdescr( buf_ptr );\n        break;\n      case 0x29:\n        printhubdescr( buf_ptr, addr );\n        break;\n      default:\n        printunkdescr( buf_ptr );\n        break;\n    }//switch( descr_type\n    buf_ptr = ( buf_ptr + descr_length );    //advance buffer pointer\n  }//while( buf_ptr &lt;=...\n  return ( rcode );\n}\n/* prints hex numbers with leading zeroes */\n// copyright, Peter H Anderson, Baltimore, MD, Nov, '07\n// source: http://www.phanderson.com/arduino/arduino_display.html\nvoid print_hex(int v, int num_places)\n{\n  int mask = 0, n, num_nibbles, digit;\n\n  for (n = 1; n &lt;= num_places; n++) {\n    mask = (mask &lt;&lt; 1) | 0x0001;\n  }\n  v = v &amp; mask; // truncate v to specified number of places\n\n  num_nibbles = num_places / 4;\n  if ((num_places % 4) != 0) {\n    ++num_nibbles;\n  }\n  do {\n    digit = ((v &gt;&gt; (num_nibbles - 1) * 4)) &amp; 0x0f;\n    Serial.print(digit, HEX);\n  }\n  while (--num_nibbles);\n}\n/* function to print configuration descriptor */\nvoid printconfdescr( uint8_t* descr_ptr )\n{\n  USB_CONFIGURATION_DESCRIPTOR* conf_ptr = ( USB_CONFIGURATION_DESCRIPTOR* )descr_ptr;\n  printProgStr(Conf_Header_str);\n  printProgStr(Conf_Totlen_str);\n  print_hex( conf_ptr-&gt;wTotalLength, 16 );\n  printProgStr(Conf_Nint_str);\n  print_hex( conf_ptr-&gt;bNumInterfaces, 8 );\n  printProgStr(Conf_Value_str);\n  print_hex( conf_ptr-&gt;bConfigurationValue, 8 );\n  printProgStr(Conf_String_str);\n  print_hex( conf_ptr-&gt;iConfiguration, 8 );\n  printProgStr(Conf_Attr_str);\n  print_hex( conf_ptr-&gt;bmAttributes, 8 );\n  printProgStr(Conf_Pwr_str);\n  print_hex( conf_ptr-&gt;bMaxPower, 8 );\n  return;\n}\n/* function to print interface descriptor */\nvoid printintfdescr( uint8_t* descr_ptr )\n{\n  USB_INTERFACE_DESCRIPTOR* intf_ptr = ( USB_INTERFACE_DESCRIPTOR* )descr_ptr;\n  printProgStr(Int_Header_str);\n  printProgStr(Int_Number_str);\n  print_hex( intf_ptr-&gt;bInterfaceNumber, 8 );\n  printProgStr(Int_Alt_str);\n  print_hex( intf_ptr-&gt;bAlternateSetting, 8 );\n  printProgStr(Int_Endpoints_str);\n  print_hex( intf_ptr-&gt;bNumEndpoints, 8 );\n  printProgStr(Int_Class_str);\n  print_hex( intf_ptr-&gt;bInterfaceClass, 8 );\n  printProgStr(Int_Subclass_str);\n  print_hex( intf_ptr-&gt;bInterfaceSubClass, 8 );\n  printProgStr(Int_Protocol_str);\n  print_hex( intf_ptr-&gt;bInterfaceProtocol, 8 );\n  printProgStr(Int_String_str);\n  print_hex( intf_ptr-&gt;iInterface, 8 );\n  return;\n}\n/* function to print endpoint descriptor */\nvoid printepdescr( uint8_t* descr_ptr )\n{\n  USB_ENDPOINT_DESCRIPTOR* ep_ptr = ( USB_ENDPOINT_DESCRIPTOR* )descr_ptr;\n  printProgStr(End_Header_str);\n  printProgStr(End_Address_str);\n  print_hex( ep_ptr-&gt;bEndpointAddress, 8 );\n  printProgStr(End_Attr_str);\n  print_hex( ep_ptr-&gt;bmAttributes, 8 );\n  printProgStr(End_Pktsize_str);\n  print_hex( ep_ptr-&gt;wMaxPacketSize, 16 );\n  printProgStr(End_Interval_str);\n  print_hex( ep_ptr-&gt;bInterval, 8 );\n\n  return;\n}\n/*function to print unknown descriptor */\nvoid printunkdescr( uint8_t* descr_ptr )\n{\n  uint8_t length = *descr_ptr;\n  uint8_t i;\n  printProgStr(Unk_Header_str);\n  printProgStr(Unk_Length_str);\n  print_hex( *descr_ptr, 8 );\n  printProgStr(Unk_Type_str);\n  print_hex( *(descr_ptr + 1 ), 8 );\n  printProgStr(Unk_Contents_str);\n  descr_ptr += 2;\n  for ( i = 0; i &lt; length; i++ ) {\n    print_hex( *descr_ptr, 8 );\n    descr_ptr++;\n  }\n}\n\n\n/* Print a string from Program Memory directly to save RAM */\nvoid printProgStr(const char* str)\n{\n  char c;\n  if (!str) return;\n  while ((c = pgm_read_byte(str++)))\n    Serial.print(c);\n}\n</code></pre> <pre><code>#if !defined(__PGMSTRINGS_H__)\n#define __PGMSTRINGS_H__\n\n#define LOBYTE(x) ((char*)(&amp;(x)))[0]\n#define HIBYTE(x) ((char*)(&amp;(x)))[1]\n#define BUFSIZE 256    //buffer size\n\n\n/* Print strings in Program Memory */\nconst char Gen_Error_str[] PROGMEM = \"\\r\\nRequest error. Error code:\\t\"; \nconst char Dev_Header_str[] PROGMEM =\"\\r\\nDevice descriptor: \";\nconst char Dev_Length_str[] PROGMEM =\"\\r\\nDescriptor Length:\\t\";\nconst char Dev_Type_str[] PROGMEM =\"\\r\\nDescriptor type:\\t\";\nconst char Dev_Version_str[] PROGMEM =\"\\r\\nUSB version:\\t\\t\";\nconst char Dev_Class_str[] PROGMEM =\"\\r\\nDevice class:\\t\\t\";\nconst char Dev_Subclass_str[] PROGMEM =\"\\r\\nDevice Subclass:\\t\";\nconst char Dev_Protocol_str[] PROGMEM =\"\\r\\nDevice Protocol:\\t\";\nconst char Dev_Pktsize_str[] PROGMEM =\"\\r\\nMax.packet size:\\t\";\nconst char Dev_Vendor_str[] PROGMEM =\"\\r\\nVendor  ID:\\t\\t\";\nconst char Dev_Product_str[] PROGMEM =\"\\r\\nProduct ID:\\t\\t\";\nconst char Dev_Revision_str[] PROGMEM =\"\\r\\nRevision ID:\\t\\t\";\nconst char Dev_Mfg_str[] PROGMEM =\"\\r\\nMfg.string index:\\t\";\nconst char Dev_Prod_str[] PROGMEM =\"\\r\\nProd.string index:\\t\";\nconst char Dev_Serial_str[] PROGMEM =\"\\r\\nSerial number index:\\t\";\nconst char Dev_Nconf_str[] PROGMEM =\"\\r\\nNumber of conf.:\\t\";\nconst char Conf_Trunc_str[] PROGMEM =\"Total length truncated to 256 bytes\";\nconst char Conf_Header_str[] PROGMEM =\"\\r\\nConfiguration descriptor:\";\nconst char Conf_Totlen_str[] PROGMEM =\"\\r\\nTotal length:\\t\\t\";\nconst char Conf_Nint_str[] PROGMEM =\"\\r\\nNum.intf:\\t\\t\";\nconst char Conf_Value_str[] PROGMEM =\"\\r\\nConf.value:\\t\\t\";\nconst char Conf_String_str[] PROGMEM =\"\\r\\nConf.string:\\t\\t\";\nconst char Conf_Attr_str[] PROGMEM =\"\\r\\nAttr.:\\t\\t\\t\";\nconst char Conf_Pwr_str[] PROGMEM =\"\\r\\nMax.pwr:\\t\\t\";\nconst char Int_Header_str[] PROGMEM =\"\\r\\n\\r\\nInterface descriptor:\";\nconst char Int_Number_str[] PROGMEM =\"\\r\\nIntf.number:\\t\\t\";\nconst char Int_Alt_str[] PROGMEM =\"\\r\\nAlt.:\\t\\t\\t\";\nconst char Int_Endpoints_str[] PROGMEM =\"\\r\\nEndpoints:\\t\\t\";\nconst char Int_Class_str[] PROGMEM =\"\\r\\nIntf. Class:\\t\\t\";\nconst char Int_Subclass_str[] PROGMEM =\"\\r\\nIntf. Subclass:\\t\\t\";\nconst char Int_Protocol_str[] PROGMEM =\"\\r\\nIntf. Protocol:\\t\\t\";\nconst char Int_String_str[] PROGMEM =\"\\r\\nIntf.string:\\t\\t\";\nconst char End_Header_str[] PROGMEM =\"\\r\\n\\r\\nEndpoint descriptor:\";\nconst char End_Address_str[] PROGMEM =\"\\r\\nEndpoint address:\\t\";\nconst char End_Attr_str[] PROGMEM =\"\\r\\nAttr.:\\t\\t\\t\";\nconst char End_Pktsize_str[] PROGMEM =\"\\r\\nMax.pkt size:\\t\\t\";\nconst char End_Interval_str[] PROGMEM =\"\\r\\nPolling interval:\\t\";\nconst char Unk_Header_str[] PROGMEM = \"\\r\\nUnknown descriptor:\";\nconst char Unk_Length_str[] PROGMEM =\"\\r\\nLength:\\t\\t\";\nconst char Unk_Type_str[] PROGMEM =\"\\r\\nType:\\t\\t\";\nconst char Unk_Contents_str[] PROGMEM =\"\\r\\nContents:\\t\";\n\n#endif // __PGMSTRINGS_H__\n</code></pre> <p>Users will need to connect a peripheral USB device to the USB-C connector, before running the example. After the example begins, users should see an output in the Serial Monitor with a description of the connected USB device.</p> <p></p> <p>The USB Host Shield with a USB-C adapter and flash drive attached.</p> USB Hubs <p>If users connect USB hubs or USB cables with a hub to the USB host shield, utilize the hub_demo example from the USB_Host_Shield_2.0 Arduino library instead. This example can be found in the File dropdown menu (i.e. File &gt; Examples &gt; USB Host Shield Library 2.0 &gt; hub_demo) and will list the USB description for the hub(s) and all the peripheral devices connected to the hub(s).</p> Only interested in the USB hub description? <p>To see just the USB description for the hub(s) connected to the USB host shield, follow the information in the library's FAQ. Utilizing the USB_dec example, uncomment lines 12-18(1).</p> <ol> <li>Each instance of <code>USBHub Hub&lt;number&gt;(&amp;Usb);</code> enables a USB hub, but the library is limited up to seven USB hubs. </li> </ol> USB_desc.ino<pre><code>USB     Usb;\n//USBHub  Hub1(&amp;Usb);\n//USBHub  Hub2(&amp;Usb);\n//USBHub  Hub3(&amp;Usb);\n//USBHub  Hub4(&amp;Usb);\n//USBHub  Hub5(&amp;Usb);\n//USBHub  Hub6(&amp;Usb);\n//USBHub  Hub7(&amp;Usb);\n</code></pre> <ul> <li> <p>Qwiic USB Hub - USB2514B     SPX-18014 <p> </p> <li> <p>SparkFun 4-in-1 Multi-USB Cable - USB-C Host     CAB-21271 <p> </p> <li> <p>SparkFun 4-in-1 Multi-USB Cable - USB-A Host     CAB-21272 <p> </p>"},{"location":"print_view/#hid-keyboard-and-mouse","title":"HID Keyboard and Mouse","text":"<p>In this example, we will be utilizing the USBHIDBootKbdAndMouse example from the USB_Host_Shield_2.0 Arduino library. This example can be found in the File dropdown menu (i.e. (1) File &gt; Examples &gt; USB Host Shield Library 2.0 &gt; HID &gt; USBHIDBootKbdAndMouse). Once the example has been opened, users should see the <code>USBHIDBootKbdAndMouse.ino</code> example sketch.</p> <ol> <li> Select the <code>USBHIDBootKbdAndMouse</code> example sketch from the <code>File</code> drop-down menu. </li> </ol> USBHIDBootKbdAndMouse.ino <pre><code>#include &lt;hidboot.h&gt;\n#include &lt;usbhub.h&gt;\n\n// Satisfy IDE, which only needs to see the include statment in the ino.\n#ifdef dobogusinclude\n#include &lt;spi4teensy3.h&gt;\n#endif\n#include &lt;SPI.h&gt;\n\nclass MouseRptParser : public MouseReportParser\n{\n  protected:\n    void OnMouseMove(MOUSEINFO *mi);\n    void OnLeftButtonUp(MOUSEINFO *mi);\n    void OnLeftButtonDown(MOUSEINFO *mi);\n    void OnRightButtonUp(MOUSEINFO *mi);\n    void OnRightButtonDown(MOUSEINFO *mi);\n    void OnMiddleButtonUp(MOUSEINFO *mi);\n    void OnMiddleButtonDown(MOUSEINFO *mi);\n};\nvoid MouseRptParser::OnMouseMove(MOUSEINFO *mi)\n{\n  Serial.print(\"dx=\");\n  Serial.print(mi-&gt;dX, DEC);\n  Serial.print(\" dy=\");\n  Serial.println(mi-&gt;dY, DEC);\n};\nvoid MouseRptParser::OnLeftButtonUp (MOUSEINFO *mi)\n{\n  Serial.println(\"L Butt Up\");\n};\nvoid MouseRptParser::OnLeftButtonDown   (MOUSEINFO *mi)\n{\n  Serial.println(\"L Butt Dn\");\n};\nvoid MouseRptParser::OnRightButtonUp    (MOUSEINFO *mi)\n{\n  Serial.println(\"R Butt Up\");\n};\nvoid MouseRptParser::OnRightButtonDown  (MOUSEINFO *mi)\n{\n  Serial.println(\"R Butt Dn\");\n};\nvoid MouseRptParser::OnMiddleButtonUp   (MOUSEINFO *mi)\n{\n  Serial.println(\"M Butt Up\");\n};\nvoid MouseRptParser::OnMiddleButtonDown (MOUSEINFO *mi)\n{\n  Serial.println(\"M Butt Dn\");\n};\n\nclass KbdRptParser : public KeyboardReportParser\n{\n    void PrintKey(uint8_t mod, uint8_t key);\n\n  protected:\n    void OnControlKeysChanged(uint8_t before, uint8_t after);\n    void OnKeyDown  (uint8_t mod, uint8_t key);\n    void OnKeyUp    (uint8_t mod, uint8_t key);\n    void OnKeyPressed(uint8_t key);\n};\n\nvoid KbdRptParser::PrintKey(uint8_t m, uint8_t key)\n{\n  MODIFIERKEYS mod;\n  *((uint8_t*)&amp;mod) = m;\n  Serial.print((mod.bmLeftCtrl   == 1) ? \"C\" : \" \");\n  Serial.print((mod.bmLeftShift  == 1) ? \"S\" : \" \");\n  Serial.print((mod.bmLeftAlt    == 1) ? \"A\" : \" \");\n  Serial.print((mod.bmLeftGUI    == 1) ? \"G\" : \" \");\n\n  Serial.print(\" &gt;\");\n  PrintHex&lt;uint8_t&gt;(key, 0x80);\n  Serial.print(\"&lt; \");\n\n  Serial.print((mod.bmRightCtrl   == 1) ? \"C\" : \" \");\n  Serial.print((mod.bmRightShift  == 1) ? \"S\" : \" \");\n  Serial.print((mod.bmRightAlt    == 1) ? \"A\" : \" \");\n  Serial.println((mod.bmRightGUI    == 1) ? \"G\" : \" \");\n};\n\nvoid KbdRptParser::OnKeyDown(uint8_t mod, uint8_t key)\n{\n  Serial.print(\"DN \");\n  PrintKey(mod, key);\n  uint8_t c = OemToAscii(mod, key);\n\n  if (c)\n    OnKeyPressed(c);\n}\n\nvoid KbdRptParser::OnControlKeysChanged(uint8_t before, uint8_t after) {\n\n  MODIFIERKEYS beforeMod;\n  *((uint8_t*)&amp;beforeMod) = before;\n\n  MODIFIERKEYS afterMod;\n  *((uint8_t*)&amp;afterMod) = after;\n\n  if (beforeMod.bmLeftCtrl != afterMod.bmLeftCtrl) {\n    Serial.println(\"LeftCtrl changed\");\n  }\n  if (beforeMod.bmLeftShift != afterMod.bmLeftShift) {\n    Serial.println(\"LeftShift changed\");\n  }\n  if (beforeMod.bmLeftAlt != afterMod.bmLeftAlt) {\n    Serial.println(\"LeftAlt changed\");\n  }\n  if (beforeMod.bmLeftGUI != afterMod.bmLeftGUI) {\n    Serial.println(\"LeftGUI changed\");\n  }\n\n  if (beforeMod.bmRightCtrl != afterMod.bmRightCtrl) {\n    Serial.println(\"RightCtrl changed\");\n  }\n  if (beforeMod.bmRightShift != afterMod.bmRightShift) {\n    Serial.println(\"RightShift changed\");\n  }\n  if (beforeMod.bmRightAlt != afterMod.bmRightAlt) {\n    Serial.println(\"RightAlt changed\");\n  }\n  if (beforeMod.bmRightGUI != afterMod.bmRightGUI) {\n    Serial.println(\"RightGUI changed\");\n  }\n\n}\n\nvoid KbdRptParser::OnKeyUp(uint8_t mod, uint8_t key)\n{\n  Serial.print(\"UP \");\n  PrintKey(mod, key);\n}\n\nvoid KbdRptParser::OnKeyPressed(uint8_t key)\n{\n  Serial.print(\"ASCII: \");\n  Serial.println((char)key);\n};\n\nUSB     Usb;\nUSBHub     Hub(&amp;Usb);\n\nHIDBoot &lt; USB_HID_PROTOCOL_KEYBOARD | USB_HID_PROTOCOL_MOUSE &gt; HidComposite(&amp;Usb);\nHIDBoot&lt;USB_HID_PROTOCOL_KEYBOARD&gt;    HidKeyboard(&amp;Usb);\nHIDBoot&lt;USB_HID_PROTOCOL_MOUSE&gt;    HidMouse(&amp;Usb);\n\nKbdRptParser KbdPrs;\nMouseRptParser MousePrs;\n\nvoid setup()\n{\n  Serial.begin( 115200 );\n#if !defined(__MIPSEL__)\n  while (!Serial); // Wait for serial port to connect - used on Leonardo, Teensy and other boards with built-in USB CDC serial connection\n#endif\n  Serial.println(\"Start\");\n\n  if (Usb.Init() == -1)\n    Serial.println(\"OSC did not start.\");\n\n  delay( 200 );\n\n  HidComposite.SetReportParser(0, &amp;KbdPrs);\n  HidComposite.SetReportParser(1, &amp;MousePrs);\n  HidKeyboard.SetReportParser(0, &amp;KbdPrs);\n  HidMouse.SetReportParser(0, &amp;MousePrs);\n}\n\nvoid loop()\n{\n  Usb.Task();\n}\n</code></pre> <p>Users will need to connect an HID device (keyboard and/or mouse) to the USB-C host shield with a USB cable, before running the example. After the example begins, users should see an output in the Serial Monitor with print out based on the user's interaction with their HID device.</p>"},{"location":"print_view/#hid-game-controller","title":"HID Game Controller","text":"<p>In these examples, we will be connecting the 8BitDo SN30 Pro to the USB-C host shield. Users will need the following items for the examples below:</p> <ul> <li> 8BitDo SN30 Pro Bluetooth Gamepad   For instructions on how to use the 8BitDo SN30 Pro, please refer to their user manual.   </li> <li>USB 2.0 Type-C Cable - 1 Meter</li> <li>USB A (Female) to Type C (Male) Converter</li> <li>Bluetooth USB Module Mini</li> </ul> <ul> <li> <p>8BitDo SN30 Pro Bluetooth Gamepad     WIG-17264 <p> </p> 8BitDo SN30 Pro Manual <p>For instructions on how to use the 8BitDo SN30 Pro, please refer to their user manual.</p> <li> <p>USB 2.0 Type-C Cable - 1 Meter     CAB-16905 <p> (Coming Soon) </p> <li> <p>USB A (Female) to Type C (Male) Converter     COM-21870 <p> </p> <li> <p>Bluetooth USB Module Mini     WRL-09434 <p> </p>"},{"location":"print_view/#usb-connection","title":"USB Connection","text":"<p>In this example, we will be utilizing the XBOXUSB example from the USB_Host_Shield_2.0 Arduino library. This example can be found in the File dropdown menu (i.e. (1) File &gt; Examples &gt; USB Host Shield Library 2.0 &gt; Xbox &gt; XBOXUSB). Once the example has been opened, users should see the <code>XBOXUSB.ino</code> example sketch.</p> <ol> <li> Select the <code>XBOXUSB</code> example sketch from the <code>File</code> drop-down menu. </li> </ol> XBOXONE.ino <pre><code>/*\n Example sketch for the Xbox 360 USB library - developed by Kristian Lauszus\n For more information visit my blog: http://blog.tkjelectronics.dk/ or\n send me an e-mail:  kristianl@tkjelectronics.com\n */\n\n#include &lt;XBOXUSB.h&gt;\n\n// Satisfy the IDE, which needs to see the include statment in the ino too.\n#ifdef dobogusinclude\n#include &lt;spi4teensy3.h&gt;\n#endif\n#include &lt;SPI.h&gt;\n\nUSB Usb;\nXBOXUSB Xbox(&amp;Usb);\n\nvoid setup() {\n  Serial.begin(115200);\n#if !defined(__MIPSEL__)\n  while (!Serial); // Wait for serial port to connect - used on Leonardo, Teensy and other boards with built-in USB CDC serial connection\n#endif\n  if (Usb.Init() == -1) {\n    Serial.print(F(\"\\r\\nOSC did not start\"));\n    while (1); //halt\n  }\n  Serial.print(F(\"\\r\\nXBOX USB Library Started\"));\n}\nvoid loop() {\n  Usb.Task();\n  if (Xbox.Xbox360Connected) {\n    if (Xbox.getButtonPress(LT) || Xbox.getButtonPress(RT)) {\n      Serial.print(\"LT: \");\n      Serial.print(Xbox.getButtonPress(LT));\n      Serial.print(\"\\tRT: \");\n      Serial.println(Xbox.getButtonPress(RT));\n      Xbox.setRumbleOn(Xbox.getButtonPress(LT), Xbox.getButtonPress(RT));\n    } else\n      Xbox.setRumbleOn(0, 0);\n\n    if (Xbox.getAnalogHat(LeftHatX) &gt; 7500 || Xbox.getAnalogHat(LeftHatX) &lt; -7500 || Xbox.getAnalogHat(LeftHatY) &gt; 7500 || Xbox.getAnalogHat(LeftHatY) &lt; -7500 || Xbox.getAnalogHat(RightHatX) &gt; 7500 || Xbox.getAnalogHat(RightHatX) &lt; -7500 || Xbox.getAnalogHat(RightHatY) &gt; 7500 || Xbox.getAnalogHat(RightHatY) &lt; -7500) {\n      if (Xbox.getAnalogHat(LeftHatX) &gt; 7500 || Xbox.getAnalogHat(LeftHatX) &lt; -7500) {\n        Serial.print(F(\"LeftHatX: \"));\n        Serial.print(Xbox.getAnalogHat(LeftHatX));\n        Serial.print(\"\\t\");\n      }\n      if (Xbox.getAnalogHat(LeftHatY) &gt; 7500 || Xbox.getAnalogHat(LeftHatY) &lt; -7500) {\n        Serial.print(F(\"LeftHatY: \"));\n        Serial.print(Xbox.getAnalogHat(LeftHatY));\n        Serial.print(\"\\t\");\n      }\n      if (Xbox.getAnalogHat(RightHatX) &gt; 7500 || Xbox.getAnalogHat(RightHatX) &lt; -7500) {\n        Serial.print(F(\"RightHatX: \"));\n        Serial.print(Xbox.getAnalogHat(RightHatX));\n        Serial.print(\"\\t\");\n      }\n      if (Xbox.getAnalogHat(RightHatY) &gt; 7500 || Xbox.getAnalogHat(RightHatY) &lt; -7500) {\n        Serial.print(F(\"RightHatY: \"));\n        Serial.print(Xbox.getAnalogHat(RightHatY));\n      }\n      Serial.println();\n    }\n\n    if (Xbox.getButtonClick(UP)) {\n      Xbox.setLedOn(LED1);\n      Serial.println(F(\"Up\"));\n    }\n    if (Xbox.getButtonClick(DOWN)) {\n      Xbox.setLedOn(LED4);\n      Serial.println(F(\"Down\"));\n    }\n    if (Xbox.getButtonClick(LEFT)) {\n      Xbox.setLedOn(LED3);\n      Serial.println(F(\"Left\"));\n    }\n    if (Xbox.getButtonClick(RIGHT)) {\n      Xbox.setLedOn(LED2);\n      Serial.println(F(\"Right\"));\n    }\n\n    if (Xbox.getButtonClick(START)) {\n      Xbox.setLedMode(ALTERNATING);\n      Serial.println(F(\"Start\"));\n    }\n    if (Xbox.getButtonClick(BACK)) {\n      Xbox.setLedBlink(ALL);\n      Serial.println(F(\"Back\"));\n    }\n    if (Xbox.getButtonClick(L3))\n      Serial.println(F(\"L3\"));\n    if (Xbox.getButtonClick(R3))\n      Serial.println(F(\"R3\"));\n\n    if (Xbox.getButtonClick(LB))\n      Serial.println(F(\"LB\"));\n    if (Xbox.getButtonClick(RB))\n      Serial.println(F(\"RB\"));\n    if (Xbox.getButtonClick(XBOX)) {\n      Xbox.setLedMode(ROTATING);\n      Serial.println(F(\"Xbox\"));\n    }\n\n    if (Xbox.getButtonClick(A))\n      Serial.println(F(\"A\"));\n    if (Xbox.getButtonClick(B))\n      Serial.println(F(\"B\"));\n    if (Xbox.getButtonClick(X))\n      Serial.println(F(\"X\"));\n    if (Xbox.getButtonClick(Y))\n      Serial.println(F(\"Y\"));\n  }\n  delay(1);\n}\n</code></pre> <p>Users will need to turn on and connect the controller to the USB-C host shield with a USB cable, before running the example.</p> <p></p> <p>8BitDo controller connected to the USB-C Host Shield with a USB-C cable.</p> <p>Note</p> <p>To turn on the controller, press the Start+X buttons. Users should see two status LEDs blinking at the bottom of the controller.</p> <p>After the example begins, users should see an output in the Serial Monitor with print out based on the user's interaction with their controller.</p>"},{"location":"print_view/#bluetooth-connection","title":"Bluetooth Connection","text":"<p>In this example, we will be utilizing the XBOXONESBT example from the USB_Host_Shield_2.0 Arduino library. This example can be found in the File dropdown menu (i.e. (1) File &gt; Examples &gt; USB Host Shield Library 2.0 &gt; Xbox &gt; XBOXONESBT). Once the example has been opened, users should see the <code>XBOXONESBT.ino</code> example sketch.</p> <ol> <li> Select the <code>XBOXONESBT</code> example sketch from the <code>File</code> drop-down menu. </li> </ol> XBOXONESBT.ino <pre><code>/*\n Example sketch for the Xbox One S Bluetooth library - developed by Kristian Sloth Lauszus\n For more information visit the Github repository: github.com/felis/USB_Host_Shield_2.0 or\n send me an e-mail:  lauszus@gmail.com\n */\n\n#include &lt;XBOXONESBT.h&gt;\n#include &lt;usbhub.h&gt;\n\n// Satisfy the IDE, which needs to see the include statement in the ino too.\n#ifdef dobogusinclude\n#include &lt;spi4teensy3.h&gt;\n#endif\n#include &lt;SPI.h&gt;\n\nUSB Usb;\n//USBHub Hub1(&amp;Usb); // Some dongles have a hub inside\nBTD Btd(&amp;Usb); // You have to create the Bluetooth Dongle instance like so\n\n/* You can create the instance of the XBOXONESBT class in two ways */\n// This will start an inquiry and then pair with the Xbox One S controller - you only have to do this once\n// You will need to hold down the Sync and Xbox button at the same time, the Xbox One S controller will then start to blink rapidly indicating that it is in pairing mode\nXBOXONESBT Xbox(&amp;Btd, PAIR);\n\n// After that you can simply create the instance like so and then press the Xbox button on the device\n//XBOXONESBT Xbox(&amp;Btd);\n\nvoid setup() {\n  Serial.begin(115200);\n#if !defined(__MIPSEL__)\n  while (!Serial); // Wait for serial port to connect - used on Leonardo, Teensy and other boards with built-in USB CDC serial connection\n#endif\n  if (Usb.Init() == -1) {\n    Serial.print(F(\"\\r\\nOSC did not start\"));\n    while (1); //halt\n  }\n  Serial.print(F(\"\\r\\nXbox One S Bluetooth Library Started\"));\n}\nvoid loop() {\n  Usb.Task();\n\n  if (Xbox.connected()) {\n    if (Xbox.getAnalogHat(LeftHatX) &gt; 7500 || Xbox.getAnalogHat(LeftHatX) &lt; -7500 || Xbox.getAnalogHat(LeftHatY) &gt; 7500 || Xbox.getAnalogHat(LeftHatY) &lt; -7500 || Xbox.getAnalogHat(RightHatX) &gt; 7500 || Xbox.getAnalogHat(RightHatX) &lt; -7500 || Xbox.getAnalogHat(RightHatY) &gt; 7500 || Xbox.getAnalogHat(RightHatY) &lt; -7500) {\n      if (Xbox.getAnalogHat(LeftHatX) &gt; 7500 || Xbox.getAnalogHat(LeftHatX) &lt; -7500) {\n        Serial.print(F(\"LeftHatX: \"));\n        Serial.print(Xbox.getAnalogHat(LeftHatX));\n        Serial.print(\"\\t\");\n      }\n      if (Xbox.getAnalogHat(LeftHatY) &gt; 7500 || Xbox.getAnalogHat(LeftHatY) &lt; -7500) {\n        Serial.print(F(\"LeftHatY: \"));\n        Serial.print(Xbox.getAnalogHat(LeftHatY));\n        Serial.print(\"\\t\");\n      }\n      if (Xbox.getAnalogHat(RightHatX) &gt; 7500 || Xbox.getAnalogHat(RightHatX) &lt; -7500) {\n        Serial.print(F(\"RightHatX: \"));\n        Serial.print(Xbox.getAnalogHat(RightHatX));\n        Serial.print(\"\\t\");\n      }\n      if (Xbox.getAnalogHat(RightHatY) &gt; 7500 || Xbox.getAnalogHat(RightHatY) &lt; -7500) {\n        Serial.print(F(\"RightHatY: \"));\n        Serial.print(Xbox.getAnalogHat(RightHatY));\n      }\n      Serial.println();\n    }\n\n    if (Xbox.getButtonPress(LT) &gt; 0 || Xbox.getButtonPress(RT) &gt; 0) {\n      if (Xbox.getButtonPress(LT) &gt; 0) {\n        Serial.print(F(\"LT: \"));\n        Serial.print(Xbox.getButtonPress(LT));\n        Serial.print(\"\\t\");\n      }\n      if (Xbox.getButtonPress(RT) &gt; 0) {\n        Serial.print(F(\"RT: \"));\n        Serial.print(Xbox.getButtonPress(RT));\n        Serial.print(\"\\t\");\n      }\n      Serial.println();\n    }\n\n    // Set rumble effect\n    static uint16_t oldLTValue, oldRTValue;\n    if (Xbox.getButtonPress(LT) != oldLTValue || Xbox.getButtonPress(RT) != oldRTValue) {\n      oldLTValue = Xbox.getButtonPress(LT);\n      oldRTValue = Xbox.getButtonPress(RT);\n      uint8_t leftRumble = map(oldLTValue, 0, 1023, 0, 255); // Map the trigger values into a byte\n      uint8_t rightRumble = map(oldRTValue, 0, 1023, 0, 255);\n      if (leftRumble &gt; 0 || rightRumble &gt; 0)\n        Xbox.setRumbleOn(leftRumble, rightRumble, leftRumble, rightRumble);\n      else\n        Xbox.setRumbleOff();\n    }\n\n    if (Xbox.getButtonClick(UP))\n      Serial.println(F(\"Up\"));\n    if (Xbox.getButtonClick(DOWN))\n      Serial.println(F(\"Down\"));\n    if (Xbox.getButtonClick(LEFT))\n      Serial.println(F(\"Left\"));\n    if (Xbox.getButtonClick(RIGHT))\n      Serial.println(F(\"Right\"));\n\n    if (Xbox.getButtonClick(VIEW))\n      Serial.println(F(\"View\"));\n    if (Xbox.getButtonClick(MENU))\n      Serial.println(F(\"Menu\"));\n    if (Xbox.getButtonClick(XBOX)) {\n      Serial.println(F(\"Xbox\"));\n      Xbox.disconnect();\n    }\n\n    if (Xbox.getButtonClick(LB))\n      Serial.println(F(\"LB\"));\n    if (Xbox.getButtonClick(RB))\n      Serial.println(F(\"RB\"));\n    if (Xbox.getButtonClick(LT))\n      Serial.println(F(\"LT\"));\n    if (Xbox.getButtonClick(RT))\n      Serial.println(F(\"RT\"));\n    if (Xbox.getButtonClick(L3))\n      Serial.println(F(\"L3\"));\n    if (Xbox.getButtonClick(R3))\n      Serial.println(F(\"R3\"));\n\n    if (Xbox.getButtonClick(A))\n      Serial.println(F(\"A\"));\n    if (Xbox.getButtonClick(B))\n      Serial.println(F(\"B\"));\n    if (Xbox.getButtonClick(X))\n      Serial.println(F(\"X\"));\n    if (Xbox.getButtonClick(Y))\n      Serial.println(F(\"Y\"));\n  }\n}\n</code></pre> <p>Users will need to connect the Bluetooth USB module to the USB-C host shield with the USB adapter before running the example. After the example begins, users should see an output in the Serial Monitor with print out based on the user's interaction with their controller.</p> <p></p> <p>Bluetooth module connected to the USB-C Host Shield; and paired with an 8BitDo controller.</p> <p>!! note     Make sure to wait until after the board restarts and executes the example, before pairing the 8BitDo controller with the Bluetooth module.</p>"},{"location":"print_view/#bluetooth-pairing-the-controller","title":"Bluetooth Pairing the Controller","text":"<p>To turn on the controller, press the Start+X buttons. Users should see two status LEDs blinking at the bottom of the controller. To pair the controller, press and hold the pair button at the top of the controller, next to the USB-C connector, for 3 seconds. Once paired, the controller should vibrate.</p>"},{"location":"print_view/#troubleshooting-tips","title":"Troubleshooting Tips","text":"<p>Need Help?</p> <p>If you need technical assistance or more information on a product that is not working as you expected, we recommend heading on over to the SparkFun Technical Assistance page for some initial troubleshooting.</p> <p> SparkFun Technical Assistance Page </p> <p>If you can't find what you need there, the SparkFun Forums is a great place to search for additional information and to ask questions.</p> <p>Account Registration Required</p> <p>If this is your first visit to our forum, you'll need to register an account to post questions.</p>"},{"location":"print_view/#initialization-failure","title":"Initialization Failure","text":"<p>The following error message, in the serial terminal, indicates that there was a problem communicating with the MAX3421E chip.</p> <pre><code>OSC did not start\n</code></pre> <p>This error occurs here in the example code:</p> <pre><code>if (Usb.Init() == -1)\n    Serial.println(\"OSC did not start.\");\n</code></pre> <p>Here are a few steps users can perform to diagnose the issue:</p> <ul> <li>Double-check the hardware connections; including, but not limited to the solder joints, header pins (male and female), etc.<ul> <li>Disconnect power from the board and try a continuity test with a multimeter.</li> </ul> </li> <li>Make sure the switches are in the correct position to provide power to the shield.<ul> <li>The shield requires a minimum 5V input voltage.</li> <li>The red, power LED should be lit when the shield is powered.</li> </ul> </li> <li>Double-check the library for any I/O pin modifications.</li> </ul>"},{"location":"print_view/#usb-hub","title":"USB Hub","text":"<p>If users connect USB hubs or USB cables with a hub to the USB host shield, refer to the hub_demo example from the USB_Host_Shield_2.0 Arduino library. This example can be found in the File dropdown menu (i.e. File &gt; Examples &gt; USB Host Shield Library 2.0 &gt; hub_demo) and will list the USB description for the hub(s) and all the peripheral devices connected to the hub(s).</p> <p>Only interested in the USB hub description?</p> <p>To see just the USB description for the hub(s) connected to the USB host shield, follow the information in the library's FAQ. Utilizing the USB_dec example, uncomment lines 12-18(1).</p> <ol> <li>Each instance of <code>USBHub Hub&lt;number&gt;(&amp;Usb);</code> enables a USB hub, but the library is limited up to seven USB hubs. </li> </ol> USB_desc.ino<pre><code>USB     Usb;\n//USBHub  Hub1(&amp;Usb);\n//USBHub  Hub2(&amp;Usb);\n//USBHub  Hub3(&amp;Usb);\n//USBHub  Hub4(&amp;Usb);\n//USBHub  Hub5(&amp;Usb);\n//USBHub  Hub6(&amp;Usb);\n//USBHub  Hub7(&amp;Usb);\n</code></pre>"},{"location":"print_view/#resources","title":"Resources:","text":""},{"location":"print_view/#product-resources","title":"Product Resources","text":"<ul> <li>Product Page</li> <li>Schematic (PDF)</li> <li>Eagle Files (ZIP)</li> <li>Board Dimensions (PDF)</li> <li>Arduino Library: USB Host Rev. 2.0</li> <li>GitHub Hardware Repo</li> </ul>"},{"location":"print_view/#additional-resources","title":"Additional Resources","text":"<ul> <li>Arduino Shields Tutorial (v2)</li> <li>Arduino Shields Product Category</li> <li>SparkFun Technical Assistance</li> </ul>"},{"location":"print_view/#hardware-component-documentation","title":"Hardware Component Documentation","text":"<ul> <li>USB Peripheral/Host Controller: MAX3421E (PDF)<ul> <li>Errata_MAX3421E (PDF)</li> <li>Programming Guide (PDF)</li> <li>Technical Articles<ul> <li>Article - Turn any video game controller into a USB mouse (PDF)</li> </ul> </li> <li>Application Notes<ul> <li>The Maxim USB Laboratory (PDF)</li> <li>Setting Up the Maxim USB Laboratory (PDF)</li> </ul> </li> </ul> </li> <li>Power Regulation:<ul> <li>MIC5205 (PDF)</li> <li>LM1117 (PDF)</li> </ul> </li> <li>Logic-Level Converter:<ul> <li>74HC4050 (PDF)</li> </ul> </li> </ul>"},{"location":"print_view/#manufacturers-resources","title":"Manufacturer's Resources","text":"<p>Maxim Integrated (now part of Analog Devices) also provides great resources for the MAX3421E USB Peripheral/Host Controller: </p> <ul> <li>MAX3421E Product Page<ul> <li>Technical Documentation</li> </ul> </li> <li>Tutorial - Turn any video game controller into a USB mouse</li> <li>Technical Support Page</li> <li>Knowledge Base Page</li> </ul>"},{"location":"resources/","title":"Resources","text":""},{"location":"resources/#product-resources","title":"Product Resources","text":"<ul> <li>Product Page</li> <li>Schematic (PDF)</li> <li>Eagle Files (ZIP)</li> <li>Board Dimensions (PDF)</li> <li>Arduino Library: USB Host Rev. 2.0</li> <li>GitHub Hardware Repo</li> </ul>"},{"location":"resources/#additional-resources","title":"Additional Resources","text":"<ul> <li>Arduino Shields Tutorial (v2)</li> <li>Arduino Shields Product Category</li> <li>SparkFun Technical Assistance</li> </ul>"},{"location":"resources/#hardware-component-documentation","title":"Hardware Component Documentation","text":"<ul> <li>USB Peripheral/Host Controller: MAX3421E (PDF)<ul> <li>Errata_MAX3421E (PDF)</li> <li>Programming Guide (PDF)</li> <li>Technical Articles<ul> <li>Article - Turn any video game controller into a USB mouse (PDF)</li> </ul> </li> <li>Application Notes<ul> <li>The Maxim USB Laboratory (PDF)</li> <li>Setting Up the Maxim USB Laboratory (PDF)</li> </ul> </li> </ul> </li> <li>Power Regulation:<ul> <li>MIC5205 (PDF)</li> <li>LM1117 (PDF)</li> </ul> </li> <li>Logic-Level Converter:<ul> <li>74HC4050 (PDF)</li> </ul> </li> </ul>"},{"location":"resources/#manufacturers-resources","title":"Manufacturer's Resources","text":"<p>Maxim Integrated (now part of Analog Devices) also provides great resources for the MAX3421E USB Peripheral/Host Controller: </p> <ul> <li>MAX3421E Product Page<ul> <li>Technical Documentation</li> </ul> </li> <li>Tutorial - Turn any video game controller into a USB mouse</li> <li>Technical Support Page</li> <li>Knowledge Base Page</li> </ul>"},{"location":"software_overview/","title":"Installation & Setup","text":""},{"location":"software_overview/#arduino-ide","title":"Arduino IDE","text":"<p>Tip</p> <p>For first-time users, who have never programmed before and are looking to use the Arduino IDE, we recommend beginning with the SparkFun Inventor's Kit (SIK), which includes a simple board like the Arduino Uno or SparkFun RedBoard and is designed to help users get started programming with the Arduino IDE.</p> <p>Most users may already be familiar with the Arduino IDE and its use. However, for those of you who have never heard the name Arduino before, feel free to check out the Arduino website. To get started with using the Arduino IDE, check out our tutorials below:</p> <ul> <li> <p>What is an Arduino? <p> </p> <li> <p>Installing the Arduino IDE <p> </p> <li> <p>Installing an Arduino Library <p> </p> <li> <p>Installing Board Definitions in the Arduino IDE <p> </p> Need help setting up the RedBoard Plus?"},{"location":"software_overview/#redboard-plus","title":"RedBoard Plus","text":"<p>The following instructions should help users get started with the RedBoard Plus. For more information about the board, please check out our hookup guide below:</p> <p> RedBoard Plus Hookup Guide </p>"},{"location":"software_overview/#ch340-driver","title":"CH340 Driver","text":"<p>Users will need to install the appropriate driver for their computer to recognize the serial-to-UART chip on their board/adapter. Most of the latest operating systems will recognize the CH340C chip on the board and automatically install the required driver.</p> <p>To manually install the CH340 driver on their computer, users can download it from the WCH website. For more information, check out our How to Install CH340 Drivers Tutorial.</p> <p> How to Install CH340 Drivers </p>"},{"location":"software_overview/#arduino-ide_1","title":"Arduino IDE","text":"<p>When selecting a board to program in the Arduino IDE, users should select the Arduino Uno from the Tools drop-down menu (_i.e. Tools &gt; Board &gt; Arduino AVR Boards &gt; Arduino Uno).</p> <p> Select the Arduino Uno from the Tools drop-down menu in the Arduino IDE. </p> Arduino IDE 2.x.x - Alternative Method <p>In the newest version of the Arduino IDE 2.<code>x</code>.<code>x</code>, users can also select their board (green) and port (blue) from the <code>Select Board &amp; Port</code> dropdown menu (yellow).</p> <p> Selecting the Arduino Uno and COM5 port from the Select Board &amp; Port drop-down menu in the Arduino IDE (v2.0.3). </p>"},{"location":"software_overview/#usb-host-library","title":"USB Host Library","text":"<p>The USB Host Library Rev. 2.0 can be installed from the library manager in the Arduino IDE.</p> <p></p> <p>USB Host Library in the library manager of the Arduino IDE.</p> <p>Info</p> <p>For more details about the library, check out the online documentation.</p> Arduino IDE (v1.x.x) <p>In the Arduino IDE v1.x.x, the library manager will have the following appearance for the USB Host Shield library:</p> <p> USB Host Library in the library manager of the Arduino IDE (v1.x.x). </p> Alternative Libraries <p>Users are welcome to try other libraries for the MAX3421E, such as the ones listed below. However, our technical support team will only provide assistance with the USB Host Library Rev. 2.0 recommended in this hookup guide.</p> <ul> <li>Arduino-Bluetooth</li> <li>Lightweight USB Host</li> <li>MAX3421E project for STM32</li> </ul>"},{"location":"software_overview/#supported-boards","title":"Supported Boards","text":"<p>For a detailed and up-to-date list of boards supported by this library, check out the <code>README.md</code> of the GitHub repository:</p> <ul> <li>All official Arduino AVR boards (Uno, Duemilanove, Mega, Mega 2560, Mega ADK, Leonardo etc.)</li> <li>Arduino Due</li> <li>Teensy (Teensy++ 1.0, Teensy 2.0, Teensy++ 2.0, Teensy 3.x, Teensy LC and Teensy 4.x)<ul> <li>For the Teensy 3.x, install this SPI library and add <code>#include &lt;spi4teensy3.h&gt;</code> to the <code>*.ino</code> sketch file.</li> </ul> </li> <li>STM32F4<ul> <li>Take a look at the following example code.</li> </ul> </li> <li>ESP8266 is supported using the ESP8266 Arduino core<ul> <li>Uses pins <code>15</code> and <code>5</code> for <code>CS</code> and <code>INT</code>, respectively.</li> <li><code>GPIO6</code> - <code>GPIO11</code> and <code>GPIO16</code> are NOT usable.</li> </ul> </li> <li>ESP32 is supported using the arduino-esp32<ul> <li><code>GPIO5</code> : <code>CS</code></li> <li><code>GPIO17</code> : <code>INT</code></li> <li><code>GPIO18</code> : <code>SCK</code></li> <li><code>GPIO19</code> : <code>POCI</code></li> <li><code>GPIO23</code> : <code>PICO</code></li> </ul> </li> </ul>"},{"location":"software_overview/#io-pin-modifications","title":"I/O Pin Modifications","text":"<p>The SPI pins used by this library are dictated by SPI library for the Arduino core being utilized and cannot be changed easily. It is recommended that the default pins of the SPI library be utilized.</p> <p>However, the USB Host Library also declares its <code>CS</code> and <code>INT</code> pins. These pins can be reconfigured in the library by modifying the UsbCore.h file:</p> <pre><code>typedef MAX3421e&lt; \"CS Pin\", \"INT Pin\" &gt; MAX3421E;\n</code></pre> <p>For instance, if a user wanted to reconfigure the <code>CS</code> pin to <code>D7</code> and the <code>INT</code> pin to <code>D2</code> of the RedBoard Plus (or any other Arduino Uno/ATmega328P based board), line 58 should read:</p> <pre><code>typedef MAX3421e&lt;P7, P2&gt; MAX3421E;\n</code></pre> <p>Tip</p> <p>The information above is an example of a pin modification. However, it is not required for the general use of the shield and the examples in this guide. For more information, please refer to the instructions in the <code>README.md</code> of the GitHub repository.</p> Other Boards <p>For other boards, users will need to modify the lines based on the microcontroller type. For example, with the SparkFun IoT RedBoard users would need to modify line 52.</p>"},{"location":"troubleshooting_tips/","title":"Troubleshooting Tips","text":"<p>Need Help?</p> <p>If you need technical assistance or more information on a product that is not working as you expected, we recommend heading on over to the SparkFun Technical Assistance page for some initial troubleshooting.</p> <p> SparkFun Technical Assistance Page </p> <p>If you can't find what you need there, the SparkFun Forums is a great place to search for additional information and to ask questions.</p> <p>Account Registration Required</p> <p>If this is your first visit to our forum, you'll need to register an account to post questions.</p>"},{"location":"troubleshooting_tips/#initialization-failure","title":"Initialization Failure","text":"<p>The following error message, in the serial terminal, indicates that there was a problem communicating with the MAX3421E chip.</p> <pre><code>OSC did not start\n</code></pre> <p>This error occurs here in the example code:</p> <pre><code>if (Usb.Init() == -1)\n    Serial.println(\"OSC did not start.\");\n</code></pre> <p>Here are a few steps users can perform to diagnose the issue:</p> <ul> <li>Double-check the hardware connections; including, but not limited to the solder joints, header pins (male and female), etc.<ul> <li>Disconnect power from the board and try a continuity test with a multimeter.</li> </ul> </li> <li>Make sure the switches are in the correct position to provide power to the shield.<ul> <li>The shield requires a minimum 5V input voltage.</li> <li>The red, power LED should be lit when the shield is powered.</li> </ul> </li> <li>Double-check the library for any I/O pin modifications.</li> </ul>"},{"location":"troubleshooting_tips/#usb-hub","title":"USB Hub","text":"<p>If users connect USB hubs or USB cables with a hub to the USB host shield, refer to the hub_demo example from the USB_Host_Shield_2.0 Arduino library. This example can be found in the File dropdown menu (i.e. File &gt; Examples &gt; USB Host Shield Library 2.0 &gt; hub_demo) and will list the USB description for the hub(s) and all the peripheral devices connected to the hub(s).</p> <p>Only interested in the USB hub description?</p> <p>To see just the USB description for the hub(s) connected to the USB host shield, follow the information in the library's FAQ. Utilizing the USB_dec example, uncomment lines 12-18(1).</p> <ol> <li>Each instance of <code>USBHub Hub&lt;number&gt;(&amp;Usb);</code> enables a USB hub, but the library is limited up to seven USB hubs. </li> </ol> USB_desc.ino<pre><code>USB     Usb;\n//USBHub  Hub1(&amp;Usb);\n//USBHub  Hub2(&amp;Usb);\n//USBHub  Hub3(&amp;Usb);\n//USBHub  Hub4(&amp;Usb);\n//USBHub  Hub5(&amp;Usb);\n//USBHub  Hub6(&amp;Usb);\n//USBHub  Hub7(&amp;Usb);\n</code></pre>"},{"location":"github/contribute/","title":"Contribute: Make an Augmentation!","text":"<p>Spot an improvement opportunity? Feel free to contribute to our open-source design and documentation. </p>"},{"location":"github/contribute/#improve-our-documentation","title":"Improve our Documentation","text":"<p>All of this documentation can be modified by you! Please help us make it better.</p> <ul> <li>These pages are contained in the <code>docs</code> folder of the SparkFun RA6M5 Thing Plus repository.</li> </ul>"},{"location":"github/contribute/#submit-a-correction","title":"Submit a Correction","text":"<ol> <li>With a GitHub account, fork this repository.</li> <li>Add your corrections or improvements to the markdown file.</li> <li>File a pull request with your changes, and enjoy making the words worlds world a better place.<ul> <li>Once received, the documentation specialist will automatically be notified.</li> <li>We will review your suggested improvements to make sure they are correct and fit within our documentation standards.</li> </ul> </li> </ol>"},{"location":"github/contribute/#improve-our-hardware-design","title":"Improve our Hardware Design","text":"<p>All of our designs are open-source! Please help us make it better.</p> <ul> <li>Our board design files are contained in the <code>Hardware</code> folder of the SparkFun RA6M5 Thing Plus repository.</li> </ul>"},{"location":"github/contribute/#submit-a-design-enhancement","title":"Submit a Design Enhancement","text":"<ol> <li>With a GitHub account, fork this repository.</li> <li>Add your design augmentation(s)</li> <li>File a pull request with your changes, and enjoy making the words worlds world a better place.<ol> <li>Once received, the engineer in charge of the original design will automatically be notified.</li> <li>We will review your suggested improvement(s) to verify that they are within our board design standards and meet our product design requirements.</li> <li> <p>If approved, we will flag these changes for our next board revision. Congrats! \ud83c\udf7b</p> <p>Info</p> <p>Even if your suggestion is accepted, these changes may not be immediately available for purchase. We may have to cycle through our current product inventory first.</p> </li> </ol> </li> </ol>"},{"location":"github/contribute/#contributors","title":"Contributors","text":"<p>Let's provide some recognition to the contributors for this project!</p> <p> </p>"},{"location":"github/file_issue/","title":"Did we make a mistake?","text":"<p>Spot something wrong? Please let us know. </p> <p>Need Help?</p> <p>If you need technical assistance or more information on a product that is not working as you expected, we recommend heading on over to the SparkFun Technical Assistance page for some initial troubleshooting. This Submit Issues page is not where users should seek assistance.</p> <p> SparkFun Technical Assistance Page </p> <p>If you can't find what you need there, the SparkFun Forums is a great place to search the product forums and ask questions.</p> <p>Account Registration Required</p> <p>For your first visit to our forum, you'll need to create a Forum Account to post questions.</p>"},{"location":"github/file_issue/#discrepancies-in-the-documentation","title":"Discrepancies in the Documentation","text":"<p>All of our documentation can be modified by you! Please help us make it better.</p> <ul> <li>The documentation files for these pages are contained in the <code>docs</code> folder of the SparkFun RA6M5 Thing Plus repository.</li> </ul>"},{"location":"github/file_issue/#spot-something-wrong","title":"\ud83d\udd0d Spot something wrong?","text":"<p>If a section of the documentation is incorrect, please open an issue and let us know.</p>"},{"location":"github/file_issue/#do-you-have-a-suggested-correction","title":"Do you have a suggested correction?","text":"<ol> <li>With a GitHub account, fork this repository.</li> <li>Add your correction(s) or improvement(s) to the markdown file(s)</li> <li>File a pull request with your changes, and enjoy making the words worlds world a better place.<ul> <li>Once received, the documentation specialist will automatically be notified.</li> <li>We will review your suggested improvement(s) to make sure they are correct and fit within our documentation standards.</li> </ul> </li> </ol>"},{"location":"github/file_issue/#problems-in-the-hardware-design","title":"Problems in the Hardware Design","text":"<p>All of our designs are open-source! Please help us make it better.</p> <ul> <li>Our board design files are contained in the <code>Hardware</code> folder of the SparkFun RA6M5 Thing Plus repository.</li> </ul>"},{"location":"github/file_issue/#does-something-not-make-sense","title":"Does something not make sense? \ud83e\udd14","text":"<p>If part of the design is confusing, please open an issue and let us know.</p>"},{"location":"github/file_issue/#did-we-forget-to-include-an-important-function-of-the-board","title":"Did we forget to include an important function of the board? \ud83e\udd26","text":"<p>If part of the board's functionality is missing, please open an issue and file a feature request.</p> <p>Design Considerations</p> <p>Please keep in mind that we may intentionally exclude certain functions of the board to meet our product design requirements.</p> <ul> <li>For example, our Qwiic Micro boards are intended to fit on a small board layout and only use I<sup>2</sup>C communication; therefore, we may not have the SPI and interrupt pins available for users.</li> </ul>"},{"location":"github/file_issue/#do-you-wish-to-contribute-directly-to-improving-the-board-design","title":"Do you wish to contribute directly to improving the board design?","text":"<ol> <li>With a GitHub account, fork this repository.</li> <li>Add your design augmentation(s)</li> <li>File a pull request with your changes, and enjoy making the words worlds world a better place.<ol> <li>Once received, the engineer in charge of the original design will automatically be notified.</li> <li>We will review your suggested improvement(s) to verify that they are within our board design standards and meet our product design requirements.</li> <li> <p>If approved, we will flag these changes for our next board revision. Congrats! \ud83c\udf7b</p> <p>Info</p> <p>Even if your suggestion is accepted, these changes may not be immediately available for purchase. We may have to cycle through our current product inventory first.</p> </li> </ol> </li> </ol>"}]}